<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>并发编程 | 不爱吃鸭脖</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="晋华的个人博客">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.d9c8cf8c.css" as="style"><link rel="preload" href="/assets/js/app.7087f587.js" as="script"><link rel="preload" href="/assets/js/2.e7663ce2.js" as="script"><link rel="preload" href="/assets/js/9.e059bdba.js" as="script"><link rel="prefetch" href="/assets/js/10.1f7e226f.js"><link rel="prefetch" href="/assets/js/11.f6e4b5e5.js"><link rel="prefetch" href="/assets/js/12.fc105dd9.js"><link rel="prefetch" href="/assets/js/13.af686786.js"><link rel="prefetch" href="/assets/js/14.b8a0a679.js"><link rel="prefetch" href="/assets/js/15.28175aeb.js"><link rel="prefetch" href="/assets/js/16.5de6a1ae.js"><link rel="prefetch" href="/assets/js/17.83f91d5b.js"><link rel="prefetch" href="/assets/js/18.c25ff30b.js"><link rel="prefetch" href="/assets/js/19.9eb4ef0f.js"><link rel="prefetch" href="/assets/js/20.6a684d39.js"><link rel="prefetch" href="/assets/js/21.95b0c4ac.js"><link rel="prefetch" href="/assets/js/22.e5cf9121.js"><link rel="prefetch" href="/assets/js/23.8d6ef789.js"><link rel="prefetch" href="/assets/js/24.83813c9e.js"><link rel="prefetch" href="/assets/js/25.669474a8.js"><link rel="prefetch" href="/assets/js/26.3287bee0.js"><link rel="prefetch" href="/assets/js/27.3841e5e7.js"><link rel="prefetch" href="/assets/js/28.cb5633ac.js"><link rel="prefetch" href="/assets/js/29.a1a1cb6d.js"><link rel="prefetch" href="/assets/js/3.c4ac17a7.js"><link rel="prefetch" href="/assets/js/30.52a15d68.js"><link rel="prefetch" href="/assets/js/31.a07d8889.js"><link rel="prefetch" href="/assets/js/32.d09edb84.js"><link rel="prefetch" href="/assets/js/33.06ef6d42.js"><link rel="prefetch" href="/assets/js/34.6da289f6.js"><link rel="prefetch" href="/assets/js/35.ee22a4e9.js"><link rel="prefetch" href="/assets/js/36.8d8c7fba.js"><link rel="prefetch" href="/assets/js/37.b28f22e1.js"><link rel="prefetch" href="/assets/js/4.242d147b.js"><link rel="prefetch" href="/assets/js/5.b37386e0.js"><link rel="prefetch" href="/assets/js/6.ccd319ae.js"><link rel="prefetch" href="/assets/js/7.80d5da9b.js"><link rel="prefetch" href="/assets/js/8.47418624.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d9c8cf8c.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="不爱吃鸭脖" class="logo"> <span class="site-name can-hide">不爱吃鸭脖</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/a9075a/" class="nav-link">Java</a></div><div class="nav-item"><a href="/pages/bc95b0/" class="nav-link">算法</a></div><div class="nav-item"><a href="/pages/6b46d1/" class="nav-link">k8s</a></div><div class="nav-item"><a href="/pages/652125/" class="nav-link">日常</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/jinhua0" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/logo.png"> <div class="blogger-info"><h3>不爱吃鸭脖</h3> <span>小学生</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/a9075a/" class="nav-link">Java</a></div><div class="nav-item"><a href="/pages/bc95b0/" class="nav-link">算法</a></div><div class="nav-item"><a href="/pages/6b46d1/" class="nav-link">k8s</a></div><div class="nav-item"><a href="/pages/652125/" class="nav-link">日常</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/jinhua0" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>java基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>并发编程</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/8bbb97/" aria-current="page" class="active sidebar-link">并发编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/8bbb97/#基础" class="sidebar-link">基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#线程的几种创建方式" class="sidebar-link">线程的几种创建方式</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#线程有几种状态" class="sidebar-link">线程有几种状态？</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#为什么需要守护线程" class="sidebar-link">为什么需要守护线程</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/8bbb97/#threadlocal" class="sidebar-link">ThreadLocal</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#为什么要有threadlocal" class="sidebar-link">为什么要有ThreadLocal</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#threadlocal是怎么实现的呢" class="sidebar-link">ThreadLocal是怎么实现的呢</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#threadlocalmap的扩容机制" class="sidebar-link">ThreadLocalMap的扩容机制</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#threadlocalmap是怎么解决hash冲突问题" class="sidebar-link">ThreadLocalMap是怎么解决hash冲突问题</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/8bbb97/#java内存模型" class="sidebar-link">Java内存模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#你对java内存模型-jmm-的理解" class="sidebar-link">你对Java内存模型（JMM）的理解？</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#原子性、可见性、有序性" class="sidebar-link">原子性、可见性、有序性</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#为什么会发生指令重排" class="sidebar-link">为什么会发生指令重排</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#为什么会出现volatile" class="sidebar-link">为什么会出现Volatile</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#happens-before" class="sidebar-link">happens-before</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#volitile的底层原理" class="sidebar-link">volitile的底层原理</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#volatile如何保证可见性的" class="sidebar-link">volatile如何保证可见性的</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#volatile如何保证有序性的" class="sidebar-link">volatile如何保证有序性的</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/8bbb97/#锁" class="sidebar-link">锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#为什么出现synchronized锁" class="sidebar-link">为什么出现synchronized锁</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#synchronized是怎样进行加锁的" class="sidebar-link">synchronized是怎样进行加锁的</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#synchronized锁是如何保证原子性、可见性、有序性" class="sidebar-link">synchronized锁是如何保证原子性、可见性、有序性</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#synchronized为什么会进行锁升级啊" class="sidebar-link">synchronized为什么会进行锁升级啊</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#如何通过cas来竞争锁" class="sidebar-link">如何通过CAS来竞争锁</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#reentrantlock出现的意义" class="sidebar-link">ReentrantLock出现的意义</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#为什么会有aqs" class="sidebar-link">为什么会有AQS</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#为什么会有cas" class="sidebar-link">为什么会有CAS</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#cas会有哪些问题" class="sidebar-link">CAS会有哪些问题</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/8bbb97/#并发工具类" class="sidebar-link">并发工具类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#为什么会有countdownlatch-倒计时器" class="sidebar-link">为什么会有CountDownLatch(倒计时器)</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/8bbb97/#线程池" class="sidebar-link">线程池</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#为什么会有线程池啊" class="sidebar-link">为什么会有线程池啊</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#线程池工作流程" class="sidebar-link">线程池工作流程</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#线程池主要参数" class="sidebar-link">线程池主要参数</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#线程池的拒绝策略" class="sidebar-link">线程池的拒绝策略</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#线程池常用的工作队列" class="sidebar-link">线程池常用的工作队列</a></li><li class="sidebar-sub-header level3"><a href="/pages/8bbb97/#常见的线程池" class="sidebar-link">常见的线程池</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>java虚拟机</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>MySQL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>消息队列</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Mybatis</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/categories/?category=Java" title="分类" data-v-06225672>Java</a></li><li data-v-06225672><a href="/categories/?category=%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B" title="分类" data-v-06225672>并发编程</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/jinhua0" target="_blank" title="作者" class="beLink" data-v-06225672>jinhua</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-07-07</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">并发编程<!----></h1>  <div class="theme-vdoing-content content__default"><h2 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h2> <h3 id="线程的几种创建方式"><a href="#线程的几种创建方式" class="header-anchor">#</a> 线程的几种创建方式</h3> <ul><li>继承Thread类，重写run()方法</li> <li>实现Runnable接口，重写run()方法</li> <li>实现Callable接口，重写call()方法，可以通过FutureTask获取任务执行的返回值</li></ul> <h3 id="线程有几种状态"><a href="#线程有几种状态" class="header-anchor">#</a> 线程有几种状态？</h3> <p>在 Java 中，线程有 6 种状态，它们分别是：</p> <ol><li><strong>新建（NEW）</strong>：当一个线程对象被创建后，它就进入了新建状态。此时它还没有开始运行。</li> <li><strong>就绪（RUNNABLE）</strong>：当调用线程对象的 <code>start()</code> 方法后，线程就进入了可运行状态。此时线程已经准备好运行，等待操作系统为它分配 CPU 时间。</li> <li><strong>运行（RUNNING）</strong>：当线程获得 CPU 时间后，它就开始运行。此时线程正在执行它的 <code>run()</code> 方法中的代码。</li> <li><strong>阻塞（BLOCKED）</strong>：当线程在等待锁时，它就进入了阻塞状态。此时线程无法继续执行，直到它获得锁。</li> <li><strong>等待（WAITING）</strong>：当线程调用了 <code>wait()</code>、<code>join()</code> 或 <code>park()</code> 方法后，它就进入了等待状态。此时线程无法继续执行，直到其他线程调用了相应的方法来唤醒它。</li> <li><strong>终止（TERMINATED）</strong>：当线程执行完毕或被中断后，它就进入了终止状态。此时线程已经结束运行。</li></ol> <p>可以使用 <code>Thread.getState()</code> 方法来获取一个线程的当前状态。</p> <p>总之，在 Java 中，线程有 6 种状态，分别是新建、可运行、运行、阻塞、等待和终止。这些状态表示了一个线程在其生命周期中的不同阶段。</p> <h3 id="为什么需要守护线程"><a href="#为什么需要守护线程" class="header-anchor">#</a> 为什么需要守护线程</h3> <p>守护线程（Daemon Thread）是一种特殊的线程，它主要用于在后台为其他线程提供服务。它与普通线程的区别在于，当 JVM 中所有非守护线程都结束时，JVM 会自动退出，而不管当前是否还有守护线程在运行 ¹。</p> <p>守护线程通常用于执行一些后台任务，例如垃圾回收、内存管理等。这些任务通常不是程序的核心部分，但又需要一直运行。当程序中所有非守护线程都结束时，这些后台任务也就没有继续运行的必要了，因此 JVM 会自动退出 ²。</p> <p>在 Java 中，可以使用 <code>Thread.setDaemon(true)</code> 方法将一个线程设置为守护线程。需要注意的是，这个方法必须在调用 <code>Thread.start()</code> 方法之前调用。下面是一个简单的例子：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Daemon thread is running&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Main thread finished&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>在上面的例子中，我们创建了一个守护线程，并使用 <code>setDaemon(true)</code> 方法将其设置为守护线程。这个线程会一直运行，并每隔一秒打印一条消息。</p> <p>在主线程中，我们等待三秒后退出。当主线程退出时，JVM 也会自动退出，因为此时已经没有非守护线程在运行了。此时，守护线程也会被强制结束。</p> <p>总之，守护线程是一种特殊的线程，它主要用于在后台为其他线程提供服务。当 JVM 中所有非守护线程都结束时，JVM 会自动退出，而不管当前是否还有守护线程在运行。</p> <h2 id="threadlocal"><a href="#threadlocal" class="header-anchor">#</a> ThreadLocal</h2> <h3 id="为什么要有threadlocal"><a href="#为什么要有threadlocal" class="header-anchor">#</a> 为什么要有ThreadLocal</h3> <p><code>ThreadLocal</code> 是 Java 中的一个类，它提供了一种将变量绑定到线程上的方法。每个线程都可以独立地访问这个变量，而不会影响其他线程中的同一个变量。这样，就可以在多线程环境下实现线程间数据的隔离 ¹。</p> <p><code>ThreadLocal</code> 的作用主要有以下几点：</p> <ol><li>避免多次传递参数。当需要在多个方法中传递同一个参数时，可以使用 <code>ThreadLocal</code> 来避免多次传递参数，打破层次间的约束 ⁴。</li> <li>线程间数据隔离。当需要在多个线程中独立地访问同一个变量时，可以使用 <code>ThreadLocal</code> 来实现线程间数据的隔离 ⁴。</li> <li>事务管理。<code>ThreadLocal</code> 可以用来存储线程事务信息，实现事务管理 ⁴。</li> <li>数据库连接和会话管理。<code>ThreadLocal</code> 可以用来存储数据库连接和会话信息，实现数据库连接和会话管理 ⁴。</li></ol> <p>下面是一个简单的例子，演示了如何使用 <code>ThreadLocal</code> 来实现线程间数据的隔离：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;Thread 1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printThreadLocalValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;Thread 2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printThreadLocalValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printThreadLocalValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">+</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>在上面的例子中，我们创建了一个 <code>ThreadLocal&lt;String&gt;</code> 对象，并在两个线程中分别调用 <code>set()</code> 方法来设置它的值。然后我们在每个线程中调用 <code>printThreadLocalValue()</code> 方法来打印出 <code>ThreadLocal</code> 对象中存储的值。</p> <p>由于每个线程都有自己独立的 <code>ThreadLocal</code> 值，因此在每个线程中打印出来的值都是该线程自己设置的值。</p> <p>总之，<code>ThreadLocal</code> 是 Java 中的一个类，它提供了一种将变量绑定到线程上的方法。它可以用来避免多次传递参数、实现线程间数据隔离、事务管理和数据库连接和会话管理等。</p> <h3 id="threadlocal是怎么实现的呢"><a href="#threadlocal是怎么实现的呢" class="header-anchor">#</a> ThreadLocal是怎么实现的呢</h3> <p><code>ThreadLocal</code> 的实现原理是通过为每个线程提供一个独立的存储空间来实现线程间数据隔离。每个线程都有一个 <code>ThreadLocalMap</code>，它是一个类似于 <code>HashMap</code> 的数据结构，用来存储 <code>ThreadLocal</code> 变量的值。<code>ThreadLocalMap</code> 以 <code>ThreadLocal</code> 对象作为键，以 <code>ThreadLocal</code> 变量的值作为值 ¹。</p> <p>当调用 <code>ThreadLocal</code> 的 <code>set()</code> 方法时，会获取当前线程的 <code>ThreadLocalMap</code> 对象，然后将 <code>ThreadLocal</code> 对象和它的值作为键值对存储到 <code>ThreadLocalMap</code> 中。当调用 <code>ThreadLocal</code> 的 <code>get()</code> 方法时，也会获取当前线程的 <code>ThreadLocalMap</code> 对象，然后根据 <code>ThreadLocal</code> 对象作为键来获取它的值 ¹。</p> <p>下面是一个简单的例子，演示了如何使用 <code>ThreadLocal</code> 来实现线程间数据隔离：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;Thread 1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printThreadLocalValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;Thread 2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printThreadLocalValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printThreadLocalValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">+</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>在上面的例子中，我们创建了一个 <code>ThreadLocal&lt;String&gt;</code> 对象，并在两个线程中分别调用 <code>set()</code> 方法来设置它的值。然后我们在每个线程中调用 <code>printThreadLocalValue()</code> 方法来打印出 <code>ThreadLocal</code> 对象中存储的值。</p> <p>由于每个线程都有自己独立的 <code>ThreadLocalMap</code>，因此在每个线程中打印出来的值都是该线程自己设置的值。</p> <p>总之，<code>ThreadLocal</code> 的实现原理是通过为每个线程提供一个独立的存储空间来实现线程间数据隔离。每个线程都有一个 <code>ThreadLocalMap</code>，它是一个类似于 <code>HashMap</code> 的数据结构，用来存储 <code>ThreadLocal</code> 变量的值。</p> <h3 id="threadlocalmap的扩容机制"><a href="#threadlocalmap的扩容机制" class="header-anchor">#</a> ThreadLocalMap的扩容机制</h3> <h3 id="threadlocalmap是怎么解决hash冲突问题"><a href="#threadlocalmap是怎么解决hash冲突问题" class="header-anchor">#</a> ThreadLocalMap是怎么解决hash冲突问题</h3> <h2 id="java内存模型"><a href="#java内存模型" class="header-anchor">#</a> Java内存模型</h2> <h3 id="你对java内存模型-jmm-的理解"><a href="#你对java内存模型-jmm-的理解" class="header-anchor">#</a> 你对Java内存模型（JMM）的理解？</h3> <ul><li>主内存</li> <li>每个线程都有私有的本地内存</li></ul> <h3 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="header-anchor">#</a> 原子性、可见性、有序性</h3> <h3 id="为什么会发生指令重排"><a href="#为什么会发生指令重排" class="header-anchor">#</a> 为什么会发生指令重排</h3> <p>指令重排是指在不改变程序执行结果的前提下，编译器和处理器对指令顺序进行重新排列，以提高程序的执行效率。这是一种常见的编译器优化技术。</p> <p>在单线程环境下，指令重排通常不会对程序的正确性产生影响，因为编译器和处理器会保证重排后的指令序列与原始指令序列在单线程环境下的执行结果相同。但是在多线程环境下，指令重排可能会导致严重的问题。</p> <p>下面是一个简单的例子，演示了指令重排可能导致的问题：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReorderExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 语句1</span>
        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 语句2</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 语句3</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> a <span class="token operator">*</span> a<span class="token punctuation">;</span> <span class="token comment">// 语句4</span>
            <span class="token comment">// ...</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在上面的例子中，<code>writer</code> 方法和 <code>reader</code> 方法分别在两个不同的线程中执行。按照代码的顺序，<code>writer</code> 方法先执行语句1，再执行语句2；<code>reader</code> 方法先执行语句3，再执行语句4。</p> <p>但是由于指令重排的存在，编译器和处理器可能会改变这些语句的执行顺序。例如，编译器可能会将 <code>writer</code> 方法中的两条语句交换顺序，使得语句2先于语句1执行。</p> <p>当这种情况发生时，就有可能出现以下情况：<code>reader</code> 线程先执行语句3，判断 <code>flag</code> 为 <code>true</code>；然后执行语句4，计算 <code>a * a</code> 的值。由于此时 <code>a</code> 的值还没有被更新为1（因为语句1还没有执行），所以计算结果为0，而不是期望的1。</p> <p>总之，在多线程环境下，指令重排可能会导致严重的问题。为了避免这种问题，Java 提供了内存屏障（memory barrier）机制来禁止特定类型的指令重排。内存屏障可以通过使用 <code>volatile</code> 变量或者同步块来实现。</p> <h3 id="为什么会出现volatile"><a href="#为什么会出现volatile" class="header-anchor">#</a> 为什么会出现Volatile</h3> <p><code>volatile</code> 是 Java 中的一个关键字，它用来修饰变量，表示该变量是易变的。<code>volatile</code> 变量具有两个特性：可见性和禁止指令重排。</p> <p>在多线程环境下，每个线程都有自己的工作内存，用来存储该线程使用到的变量的副本。当一个线程修改了一个变量的值时，这个修改只会更新工作内存中的副本，而不会立即更新主内存中的值。这就导致了其他线程可能无法立即看到这个修改。</p> <p>为了解决这个问题，Java 提供了 <code>volatile</code> 关键字。当一个变量被声明为 <code>volatile</code> 时，它就具有了可见性。这意味着当一个线程修改了一个 <code>volatile</code> 变量的值时，这个修改会立即更新到主内存中；当其他线程读取这个 <code>volatile</code> 变量的值时，它们会从主内存中读取最新的值。</p> <p>此外，<code>volatile</code> 还具有禁止指令重排的特性。正如前面所述，指令重排可能会导致严重的问题。为了避免这种问题，Java 提供了内存屏障机制来禁止特定类型的指令重排。当一个变量被声明为 <code>volatile</code> 时，编译器和处理器就不会对它进行指令重排。</p> <p>总之，<code>volatile</code> 关键字用来解决多线程环境下变量可见性和指令重排问题。它能够保证多个线程之间对共享变量的操作是可见的，并且禁止对 <code>volatile</code> 变量进行指令重排。</p> <h3 id="happens-before"><a href="#happens-before" class="header-anchor">#</a> happens-before</h3> <p><code>happens-before</code> 是 Java 内存模型中的一个重要概念，它用来描述两个操作之间的偏序关系。如果操作 A <code>happens-before</code> 操作 B，那么操作 A 的结果对操作 B 可见，且操作 A 的执行顺序在操作 B 之前。</p> <p><code>happens-before</code> 关系用来保证多线程环境下的数据一致性。在多线程环境下，由于编译器优化、处理器乱序执行和缓存一致性等原因，不同线程之间对共享变量的操作可能会出现不一致的情况。为了解决这个问题，Java 提供了 <code>happens-before</code> 关系来定义两个操作之间的偏序关系。</p> <p>Java 内存模型定义了若干种 <code>happens-before</code> 规则，例如：</p> <ul><li>程序顺序规则：在一个线程中，按照程序顺序，前面的操作 <code>happens-before</code> 后面的操作。</li> <li>监视器锁规则：对一个锁的解锁 <code>happens-before</code> 随后对这个锁的加锁。</li> <li><code>volatile</code> 变量规则：对一个 <code>volatile</code> 变量的写入操作 <code>happens-before</code> 随后对这个变量的读取操作。</li> <li>线程启动规则：线程的启动操作 <code>happens-before</code> 线程中的任意操作。</li> <li>线程终止规则：线程中的任意操作 <code>happens-before</code> 线程的终止检测。</li></ul> <p>通过使用这些规则，程序员可以在多线程环境下编写正确的并发程序。</p> <p>总之，<code>happens-before</code> 关系是 Java 内存模型中用来描述两个操作之间偏序关系的概念。它能够保证多线程环境下的数据一致性，并帮助程序员编写正确的并发程序。</p> <h3 id="volitile的底层原理"><a href="#volitile的底层原理" class="header-anchor">#</a> volitile的底层原理</h3> <p>volatile 是 Java 提供的一种轻量级的同步机制，它能够保证变量的可见性和有序性，但不能保证原子性。它的底层实现原理是内存屏障（Memory Barrier）1。</p> <p>在多线程环境中，每个线程都有自己的工作内存，它们会从主内存中读取共享变量的值，并将其缓存在工作内存中。当一个线程修改了共享变量的值后，它会将修改后的值写回主内存。但是，由于各个线程之间并不共享工作内存，因此其他线程可能无法立即看到共享变量被修改后的值。这就是所谓的可见性问题。</p> <p>为了解决这个问题，Java 提供了 volatile 关键字。当一个变量被声明为 volatile 时，JVM 会在每次读取该变量之前插入一个 LoadLoad 屏障和一个 LoadStore 屏障，在每次写入该变量之后插入一个 StoreStore 屏障和一个 StoreLoad 屏障。</p> <p>这些屏障能够保证 volatile 变量的可见性和有序性。例如，在读取一个 volatile 变量之前，JVM 会执行 LoadLoad 屏障和 LoadStore 屏障，以确保之前所有的读操作和写操作都已完成。在写入一个 volatile 变量之后，JVM 会执行 StoreStore 屏障和 StoreLoad 屏障，以确保写操作对其他线程立即可见，并且禁止指令重排序。</p> <h3 id="volatile如何保证可见性的"><a href="#volatile如何保证可见性的" class="header-anchor">#</a> volatile如何保证可见性的</h3> <h3 id="volatile如何保证有序性的"><a href="#volatile如何保证有序性的" class="header-anchor">#</a> volatile如何保证有序性的</h3> <h2 id="锁"><a href="#锁" class="header-anchor">#</a> 锁</h2> <h3 id="为什么出现synchronized锁"><a href="#为什么出现synchronized锁" class="header-anchor">#</a> 为什么出现synchronized锁</h3> <p>synchronized 是 Java 中的一个关键字，它可以用来保护资源线程安全的同步锁。它锁定的是一个个对象，实现的方式是在对象头上做出标记，表示这个对象上锁了，是哪个线程持有的锁以及当前使用的是什么锁方式¹。这样可以保证同步代码块中的代码执行是串行执行的¹。</p> <p>synchronized 关键字可以加在方法上，也可以新建一个同步代码块并且自定义 monitor 锁对象³。它与 Lock 显式的加锁和解锁不同，synchronized 的加解锁是隐式的，尤其是抛异常的时候也能保证释放锁³。</p> <h3 id="synchronized是怎样进行加锁的"><a href="#synchronized是怎样进行加锁的" class="header-anchor">#</a> synchronized是怎样进行加锁的</h3> <p><code>synchronized</code>关键字可以用来保护代码块或方法，确保同一时间只有一个线程可以访问它。当一个线程进入<code>synchronized</code>代码块或方法时，它会自动获取锁。如果另一个线程试图进入相同的<code>synchronized</code>代码块或方法，它将被阻塞，直到第一个线程释放锁。</p> <p>在底层，<code>synchronized</code>关键字通过对象监视器（monitor）来实现加锁。当一个线程进入<code>synchronized</code>代码块或方法时，它会执行一个名为<code>monitorenter</code>的指令，该指令会尝试获取与锁对象关联的监视器。如果获取成功，监视器中的计数器会增加，表示该线程持有锁。当线程离开<code>synchronized</code>代码块或方法时，它会执行一个名为<code>monitorexit</code>的指令，该指令会递减监视器中的计数器。如果计数器递减为0，则表示该线程不再持有锁，并且锁被释放。</p> <p><code>synchronized</code>关键字还支持可重入性。这意味着如果一个线程已经持有锁，它可以再次进入相同的<code>synchronized</code>代码块或方法而不会被阻塞。每次进入<code>synchronized</code>代码块或方法时，监视器中的计数器都会增加。当线程离开<code>synchronized</code>代码块或方法时，计数器会递减。</p> <h3 id="synchronized锁是如何保证原子性、可见性、有序性"><a href="#synchronized锁是如何保证原子性、可见性、有序性" class="header-anchor">#</a> synchronized锁是如何保证原子性、可见性、有序性</h3> <p><code>synchronized</code>关键字能够保证原子性、可见性和有序性。</p> <ul><li><p>原子性：当一个线程进入<code>synchronized</code>代码块或方法时，它会自动获取锁。如果另一个线程试图进入相同的<code>synchronized</code>代码块或方法，它将被阻塞，直到第一个线程释放锁。这样，就能保证同一时间只有一个线程能够访问该代码块或方法，从而保证了原子性。</p></li> <li><p>可见性：当一个线程进入<code>synchronized</code>代码块或方法时，它会在工作内存中创建一个锁记录（Lock Record），并将主内存中的变量值复制到工作内存中。当线程离开<code>synchronized</code>代码块或方法时，它会把工作内存中的变量值刷新回主内存。这样，就能保证不同线程之间对共享变量的修改能够及时地被其他线程看到，从而保证了可见性。</p></li> <li><p>有序性：在Java内存模型中，有一个<code>happens-before</code>原则。根据这个原则，对于一个锁的解锁操作<code>happens-before</code>于后续对同一个锁的加锁操作。这意味着，在一个线程释放锁之前对共享变量的修改，在随后另一个线程获取同一个锁时将是可见的。这样，就能保证<code>synchronized</code>代码块或方法内部的操作是有序的。</p></li></ul> <h3 id="synchronized为什么会进行锁升级啊"><a href="#synchronized为什么会进行锁升级啊" class="header-anchor">#</a> synchronized为什么会进行锁升级啊</h3> <p><code>synchronized</code>关键字的锁升级是为了提高性能。在Java 6之前，<code>synchronized</code>关键字只能使用重量级锁，这种锁的开销很大，因为它需要在操作系统层面进行线程切换。为了减少这种开销，Java 6引入了偏向锁和轻量级锁。</p> <p>偏向锁是一种针对单线程执行的优化。当一个线程第一次获取<code>synchronized</code>关键字保护的锁时，它会在对象头中记录自己的线程ID。如果该线程再次获取相同的锁，它只需要检查对象头中的线程ID是否与自己相同，而不需要进行任何同步操作。这样就能大大减少获取锁的开销。</p> <p>轻量级锁是一种针对多线程竞争不激烈的情况下的优化。当一个线程试图获取<code>synchronized</code>关键字保护的锁时，它会先尝试使用CAS操作将对象头中的Mark Word替换为指向自己栈帧中的锁记录（Lock Record）的指针。如果CAS操作成功，则该线程获取到了锁；否则，该线程会进行自旋等待，尝试再次获取锁。轻量级锁避免了重量级锁在操作系统层面进行线程切换的开销，但如果多个线程同时竞争同一个锁，自旋等待会消耗大量CPU资源。</p> <p>当多个线程同时竞争同一个<code>synchronized</code>关键字保护的锁时，偏向锁和轻量级锁可能无法满足需求。此时，JVM会将锁升级为重量级锁。重量级锁通过在操作系统层面进行线程切换来实现同步，虽然开销较大，但能够保证在激烈竞争的情况下仍能正确地实现同步。</p> <p>总之，<code>synchronized</code>关键字通过使用偏向锁、轻量级锁和重量级锁来适应不同的竞争情况，从而提高性能。</p> <h3 id="如何通过cas来竞争锁"><a href="#如何通过cas来竞争锁" class="header-anchor">#</a> 如何通过CAS来竞争锁</h3> <p>CAS（Compare And Swap）是一种无锁的原子操作，它能够在多线程环境下安全地更新共享变量。CAS操作需要三个参数：一个内存地址V，一个期望值A和一个新值B。CAS操作会比较内存地址V中的值是否等于期望值A，如果相等，则将内存地址V中的值更新为新值B，并返回true；否则不做任何操作，并返回false。</p> <p>在<code>synchronized</code>关键字的轻量级锁实现中，CAS操作用于将对象头中的Mark Word替换为指向线程栈帧中的锁记录（Lock Record）的指针。当一个线程试图获取<code>synchronized</code>关键字保护的锁时，它会先在自己的栈帧中创建一个锁记录（Lock Record），并将对象头中的Mark Word复制到锁记录中。然后，该线程会使用CAS操作尝试将对象头中的Mark Word替换为指向锁记录的指针。如果CAS操作成功，则该线程获取到了锁；否则，该线程会进行自旋等待，尝试再次获取锁。</p> <p>举个例子，假设有两个线程A和B同时竞争同一个<code>synchronized</code>关键字保护的锁。当线程A和线程B都创建好了各自的锁记录后，它们都会尝试使用CAS操作将对象头中的Mark Word替换为指向各自锁记录的指针。由于CAS操作是原子的，所以只有一个线程能够成功替换Mark Word。假设线程A成功替换了Mark Word，则它获取到了锁；而线程B则会进行自旋等待，尝试再次获取锁。</p> <h3 id="reentrantlock出现的意义"><a href="#reentrantlock出现的意义" class="header-anchor">#</a> ReentrantLock出现的意义</h3> <p><code>ReentrantLock</code>是Java并发包中提供的一种可重入锁，它与<code>synchronized</code>关键字类似，都能够实现线程同步。然而，<code>ReentrantLock</code>比<code>synchronized</code>关键字更加灵活，提供了更多的功能。</p> <p>下面是一些<code>ReentrantLock</code>相对于<code>synchronized</code>关键字的优点：</p> <ul><li><code>ReentrantLock</code>支持公平锁和非公平锁。公平锁能够保证线程按照请求锁的顺序来获取锁，而非公平锁则不能保证这一点。相比之下，<code>synchronized</code>关键字只能实现非公平锁。</li> <li><code>ReentrantLock</code>提供了一个Condition类，能够让线程在特定条件下等待或被唤醒。这比<code>synchronized</code>关键字中的wait()和notify()方法更加灵活，因为一个锁可以有多个Condition对象。</li> <li><code>ReentrantLock</code>提供了可中断的获取锁操作。当一个线程正在等待获取锁时，其他线程可以调用它的interrupt()方法来中断它的等待。相比之下，使用<code>synchronized</code>关键字时，线程在等待获取锁时无法被中断。</li> <li><code>ReentrantLock</code>提供了尝试获取锁的操作。线程可以尝试在指定时间内获取锁，如果获取失败，则返回false。这比<code>synchronized</code>关键字更加灵活，因为它允许线程在无法获取锁时执行其他操作。</li></ul> <p>总之，虽然<code>synchronized</code>关键字和<code>ReentrantLock</code>都能够实现线程同步，但是<code>ReentrantLock</code>比<code>synchronized</code>关键字更加灵活，提供了更多的功能。在某些情况下，使用<code>ReentrantLock</code>能够编写出更加高效、灵活的并发代码。</p> <h3 id="为什么会有aqs"><a href="#为什么会有aqs" class="header-anchor">#</a> 为什么会有AQS</h3> <p>AQS（AbstractQueuedSynchronizer）是Java并发包中的一个重要类，它提供了一种用于实现阻塞锁和相关同步器（如信号量、CountDownLatch等）的框架。AQS的出现是为了简化阻塞锁和相关同步器的实现，并提供一种统一、高效的实现方式。</p> <p>AQS的核心思想是基于一个FIFO（先进先出）的等待队列来实现阻塞锁和相关同步器。当一个线程试图获取锁或者等待某个条件时，如果不能立即满足，则会将该线程放入等待队列中。当锁被释放或者条件被满足时，等待队列中的线程会被唤醒并重新尝试获取锁或者等待条件。</p> <p>AQS内部维护了一个状态变量，用于表示锁或者相关同步器的状态。子类可以通过定义对状态变量的操作来实现自己的同步语义。例如，ReentrantLock类就是通过定义对状态变量的操作来实现可重入锁的语义。</p> <p>总之，AQS是Java并发包中的一个重要类，它提供了一种用于实现阻塞锁和相关同步器的框架。AQS的出现简化了阻塞锁和相关同步器的实现，并提供了一种统一、高效的实现方式。</p> <h3 id="为什么会有cas"><a href="#为什么会有cas" class="header-anchor">#</a> 为什么会有CAS</h3> <p>CAS（Compare And Swap）是一种无锁的原子操作，它能够在多线程环境下安全地更新共享变量。CAS操作的出现是为了解决多线程环境下的同步问题，它提供了一种高效、无锁的方式来实现线程同步。</p> <p>在多线程环境下，多个线程可能会同时访问和修改共享变量。如果不进行同步，那么这些线程之间的操作可能会相互干扰，导致数据不一致等问题。为了解决这个问题，我们需要使用锁来保护共享变量。</p> <p>然而，传统的锁机制（如互斥锁、读写锁等）通常都需要在操作系统层面进行线程切换，这会带来很大的开销。为了减少这种开销，研究人员提出了一种无锁的原子操作——CAS。</p> <p>CAS操作能够在不使用锁的情况下安全地更新共享变量。它通过硬件指令来实现原子性，能够保证在多线程环境下的安全性。相比传统的锁机制，CAS操作具有更高的性能和更低的开销。</p> <p>总之，CAS操作的出现是为了解决多线程环境下的同步问题，它提供了一种高效、无锁的方式来实现线程同步。</p> <h3 id="cas会有哪些问题"><a href="#cas会有哪些问题" class="header-anchor">#</a> CAS会有哪些问题</h3> <p>尽管CAS操作能够在多线程环境下安全地更新共享变量，但它并不是万能的。CAS操作也有一些问题和局限性，主要包括以下几点：</p> <ul><li>ABA问题：CAS操作在判断共享变量是否被修改时，只会比较变量的当前值和期望值是否相等。然而，如果一个变量在被修改后又被修改回原值，那么CAS操作就无法检测到这种情况。这就是所谓的ABA问题。为了解决这个问题，研究人员提出了一种带版本号的CAS操作，它能够检测共享变量在被修改过程中的版本变化。</li> <li>自旋开销：如果CAS操作失败，那么线程通常会进行自旋等待，尝试再次执行CAS操作。然而，如果多个线程同时竞争同一个共享变量，那么自旋等待会消耗大量的CPU资源。在竞争激烈的情况下，CAS操作的性能可能不如传统的锁机制。</li> <li>只能保护一个变量：CAS操作只能保护一个共享变量。如果需要同时保护多个共享变量，那么就需要使用多个CAS操作来实现。然而，多个CAS操作之间并不是原子的，这可能会导致数据不一致等问题。</li></ul> <p>总之，尽管CAS操作能够在多线程环境下安全地更新共享变量，但它也有一些问题和局限性。在使用CAS操作时，需要仔细考虑这些问题，并采取相应的措施来解决它们。</p> <h2 id="并发工具类"><a href="#并发工具类" class="header-anchor">#</a> 并发工具类</h2> <h3 id="为什么会有countdownlatch-倒计时器"><a href="#为什么会有countdownlatch-倒计时器" class="header-anchor">#</a> 为什么会有CountDownLatch(倒计时器)</h3> <p>让多个线程同步的去完成一些操作</p> <h2 id="线程池"><a href="#线程池" class="header-anchor">#</a> 线程池</h2> <h3 id="为什么会有线程池啊"><a href="#为什么会有线程池啊" class="header-anchor">#</a> 为什么会有线程池啊</h3> <p>线程池（Thread Pool）是一种管理线程的工具，它能够复用已创建的线程来执行任务，从而减少线程创建和销毁的开销。线程池的出现是为了解决多线程环境下的性能问题，它提供了一种高效、灵活的方式来管理线程。</p> <p>在多线程环境下，如果需要频繁地创建和销毁线程，那么这些操作会带来很大的开销。每次创建一个新线程都需要分配内存、初始化线程栈和寄存器等资源；每次销毁一个线程都需要回收这些资源。这些操作会消耗大量的CPU时间和内存空间。</p> <p>为了减少这种开销，研究人员提出了线程池的概念。线程池维护了一组已创建的线程，当需要执行一个任务时，它会从池中取出一个空闲的线程来执行该任务；当任务执行完毕后，该线程会被归还到池中，等待下一次使用。</p> <p>通过复用已创建的线程来执行任务，线程池能够减少线程创建和销毁的开销。此外，线程池还能够有效地管理线程数量，避免过多的线程竞争导致系统性能下降。</p> <p>总之，线程池是一种管理线程的工具，它能够复用已创建的线程来执行任务，从而减少线程创建和销毁的开销。线程池的出现提供了一种高效、灵活的方式来管理线程。</p> <h3 id="线程池工作流程"><a href="#线程池工作流程" class="header-anchor">#</a> 线程池工作流程</h3> <ul><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li> <li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li> <li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li> <li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会根据拒绝策略来对应处理。</li></ul> <h3 id="线程池主要参数"><a href="#线程池主要参数" class="header-anchor">#</a> 线程池主要参数</h3> <p>线程池主要有以下几个参数：</p> <ul><li>核心线程数（corePoolSize）：线程池中核心线程的数量。当线程池中的线程数量小于核心线程数时，即使有空闲线程，也会创建新的线程来执行任务。</li> <li>最大线程数（maximumPoolSize）：线程池中最大线程的数量。当线程池中的线程数量达到最大值时，新提交的任务会被拒绝。</li> <li>空闲线程存活时间（keepAliveTime）：当线程池中的线程数量超过核心线程数时，多余的空闲线程在等待新任务时最多能等待的时间。超过这个时间后，空闲线程会被终止。</li> <li>任务队列（workQueue）：用于存储等待执行的任务的阻塞队列。当所有工作线程都处于忙碌状态时，新提交的任务会被放入任务队列中等待执行。</li> <li>线程工厂（threadFactory）：用于创建新线程的工厂对象。可以通过指定自定义的线程工厂来控制新创建的线程的名称、优先级等属性。</li> <li>拒绝策略（handler）：当任务队列已满且线程池中的线程数量达到最大值时，新提交的任务会被拒绝。拒绝策略用于处理这种情况。</li></ul> <h3 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="header-anchor">#</a> 线程池的拒绝策略</h3> <ul><li>AbortPolicy ：直接抛出异常，默认使用此策略</li> <li>CallerRunsPolicy：用调用者所在的线程来执行任务</li> <li>DiscardOldestPolicy：丢弃阻塞队列里最老的任务，也就是队列里靠前的任务</li> <li>DiscardPolicy ：当前任务直接丢弃</li></ul> <h3 id="线程池常用的工作队列"><a href="#线程池常用的工作队列" class="header-anchor">#</a> 线程池常用的工作队列</h3> <p>线程池中常用的工作队列有以下几种：</p> <ul><li><code>ArrayBlockingQueue</code>：基于数组实现的有界阻塞队列。这种队列的容量是固定的，当队列满时，新提交的任务会被拒绝。</li> <li><code>LinkedBlockingQueue</code>：基于链表实现的阻塞队列。这种队列的容量可以是固定的，也可以是无限的。当队列满时，新提交的任务会被拒绝。</li> <li><code>SynchronousQueue</code>：一种特殊的阻塞队列，它没有容量。每个插入操作都必须等待一个相应的删除操作，反之亦然。这种队列通常用于实现线程池中的缓存任务。</li> <li><code>PriorityBlockingQueue</code>：基于优先级堆实现的无界阻塞队列。这种队列中的元素按照优先级顺序进行排序。当线程池中的线程数量达到最大值时，新提交的任务会根据优先级顺序被执行。</li></ul> <p>这些工作队列各有优缺点，应根据实际情况来选择合适的工作队列。例如，如果需要控制线程池中任务的数量，可以使用<code>ArrayBlockingQueue</code>或<code>LinkedBlockingQueue</code>；如果需要按照任务的优先级顺序来执行任务，可以使用<code>PriorityBlockingQueue</code>。</p> <h3 id="常见的线程池"><a href="#常见的线程池" class="header-anchor">#</a> 常见的线程池</h3> <p>Java并发包中提供了几种常用的线程池，它们分别是：</p> <ul><li><code>FixedThreadPool</code>：固定大小的线程池。这种线程池中的线程数量是固定的，当所有线程都处于忙碌状态时，新提交的任务会被放入工作队列中等待执行。</li> <li><code>CachedThreadPool</code>：缓存型线程池。这种线程池中的线程数量不固定，当有新任务提交时，如果有空闲线程，则使用空闲线程来执行任务；否则，创建新的线程来执行任务。当线程空闲时间超过一定时间后，会被终止。</li> <li><code>SingleThreadExecutor</code>：单线程线程池。这种线程池中只有一个线程，所有提交的任务会按照顺序依次执行。</li> <li><code>ScheduledThreadPoolExecutor</code>：定时任务线程池。这种线程池能够在指定时间执行任务，或者以指定的时间间隔周期性地执行任务。</li></ul> <p>下面是一个简单的例子，它展示了如何使用<code>FixedThreadPool</code>来执行任务：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ExecutorService</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Executors</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FixedThreadPoolDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ExecutorService</span> threadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">final</span> <span class="token keyword">int</span> taskId <span class="token operator">=</span> i<span class="token punctuation">;</span>
            threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Task &quot;</span> <span class="token operator">+</span> taskId <span class="token operator">+</span> <span class="token string">&quot; is running&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>在这个例子中，我们使用<code>Executors.newFixedThreadPool()</code>方法创建了一个固定大小为2的线程池。然后，我们向线程池中提交了10个任务。由于线程池的大小为2，所以最多只能有两个任务同时执行；其他任务会被放入工作队列中等待执行。</p> <p>通过这个例子，你可以看到如何使用<code>FixedThreadPool</code>来执行任务。需要注意的是，在使用完线程池后，应调用<code>shutdown()</code>方法来关闭线程池。</p></div></div>  <div class="page-edit"><!----> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/e9c9df/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">java集合</div></a> <a href="/pages/68d5c9/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">java虚拟机</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/e9c9df/" class="prev">java集合</a></span> <span class="next"><a href="/pages/68d5c9/">java虚拟机</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/d2b13d/"><div>
            实习技术
            <!----></div></a> <span class="date">08-24</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/39be8a/"><div>
            sql
            <!----></div></a> <span class="date">07-28</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/4375ac/"><div>
            git命令
            <!----></div></a> <span class="date">07-26</span></dt></dl> <dl><dd></dd> <dt><a href="/archives" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://www.zhihu.com/people/zhi-qing-72-50" title="知乎" target="_blank" class="iconfont icon-zhihu"></a><a href="https://github.com/jinhua0" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://space.bilibili.com/352135891?spm_id_from=333.337.0.0" title="blibli" target="_blank" class="iconfont icon-bilibili"></a><a href="er2578912608@163.com" title="邮箱" target="_blank" class="iconfont icon-youjian"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2023
    <span>Evan Xu | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.7087f587.js" defer></script><script src="/assets/js/2.e7663ce2.js" defer></script><script src="/assets/js/9.e059bdba.js" defer></script>
  </body>
</html>
