<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MySQL | 不爱吃鸭脖</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="晋华的个人博客">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.d9c8cf8c.css" as="style"><link rel="preload" href="/assets/js/app.7087f587.js" as="script"><link rel="preload" href="/assets/js/2.e7663ce2.js" as="script"><link rel="preload" href="/assets/js/13.af686786.js" as="script"><link rel="prefetch" href="/assets/js/10.1f7e226f.js"><link rel="prefetch" href="/assets/js/11.f6e4b5e5.js"><link rel="prefetch" href="/assets/js/12.fc105dd9.js"><link rel="prefetch" href="/assets/js/14.b8a0a679.js"><link rel="prefetch" href="/assets/js/15.28175aeb.js"><link rel="prefetch" href="/assets/js/16.5de6a1ae.js"><link rel="prefetch" href="/assets/js/17.83f91d5b.js"><link rel="prefetch" href="/assets/js/18.c25ff30b.js"><link rel="prefetch" href="/assets/js/19.9eb4ef0f.js"><link rel="prefetch" href="/assets/js/20.6a684d39.js"><link rel="prefetch" href="/assets/js/21.95b0c4ac.js"><link rel="prefetch" href="/assets/js/22.e5cf9121.js"><link rel="prefetch" href="/assets/js/23.8d6ef789.js"><link rel="prefetch" href="/assets/js/24.83813c9e.js"><link rel="prefetch" href="/assets/js/25.669474a8.js"><link rel="prefetch" href="/assets/js/26.3287bee0.js"><link rel="prefetch" href="/assets/js/27.3841e5e7.js"><link rel="prefetch" href="/assets/js/28.cb5633ac.js"><link rel="prefetch" href="/assets/js/29.a1a1cb6d.js"><link rel="prefetch" href="/assets/js/3.c4ac17a7.js"><link rel="prefetch" href="/assets/js/30.52a15d68.js"><link rel="prefetch" href="/assets/js/31.a07d8889.js"><link rel="prefetch" href="/assets/js/32.d09edb84.js"><link rel="prefetch" href="/assets/js/33.06ef6d42.js"><link rel="prefetch" href="/assets/js/34.6da289f6.js"><link rel="prefetch" href="/assets/js/35.ee22a4e9.js"><link rel="prefetch" href="/assets/js/36.8d8c7fba.js"><link rel="prefetch" href="/assets/js/37.b28f22e1.js"><link rel="prefetch" href="/assets/js/4.242d147b.js"><link rel="prefetch" href="/assets/js/5.b37386e0.js"><link rel="prefetch" href="/assets/js/6.ccd319ae.js"><link rel="prefetch" href="/assets/js/7.80d5da9b.js"><link rel="prefetch" href="/assets/js/8.47418624.js"><link rel="prefetch" href="/assets/js/9.e059bdba.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d9c8cf8c.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="不爱吃鸭脖" class="logo"> <span class="site-name can-hide">不爱吃鸭脖</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/a9075a/" class="nav-link">Java</a></div><div class="nav-item"><a href="/pages/bc95b0/" class="nav-link">算法</a></div><div class="nav-item"><a href="/pages/6b46d1/" class="nav-link">k8s</a></div><div class="nav-item"><a href="/pages/652125/" class="nav-link">日常</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/jinhua0" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/logo.png"> <div class="blogger-info"><h3>不爱吃鸭脖</h3> <span>小学生</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/a9075a/" class="nav-link">Java</a></div><div class="nav-item"><a href="/pages/bc95b0/" class="nav-link">算法</a></div><div class="nav-item"><a href="/pages/6b46d1/" class="nav-link">k8s</a></div><div class="nav-item"><a href="/pages/652125/" class="nav-link">日常</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/jinhua0" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>java基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>并发编程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>java虚拟机</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>MySQL</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/79a23c/" aria-current="page" class="active sidebar-link">MySQL</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/79a23c/#基础" class="sidebar-link">基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#数据库三大范式" class="sidebar-link">数据库三大范式</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#varchar-与-char的区别" class="sidebar-link">varchar 与 char的区别</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#count-1-、count-与-count-列名-的区别" class="sidebar-link">count(1)、count(*) 与 count(列名) 的区别？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/79a23c/#存储引擎" class="sidebar-link">存储引擎</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#innodb-和-mylsam-主要有什么区别" class="sidebar-link">InnoDB 和 MylSAM 主要有什么区别？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/79a23c/#日志" class="sidebar-link">日志</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#undo-log-binlog-redo-log" class="sidebar-link">undo log , binlog , redo log</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#什么叫dml语句" class="sidebar-link">什么叫DML语句</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#为什么需要-undo-log" class="sidebar-link">为什么需要 undo log？</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#readview" class="sidebar-link">ReadView</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#undo-log-是如何刷盘-持久化到磁盘-的" class="sidebar-link">undo log 是如何刷盘（持久化到磁盘）的？</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#为什么需要-buffer-pool" class="sidebar-link">为什么需要 Buffer Pool？</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#为什么需要-redo-log" class="sidebar-link">为什么需要 redo log ？</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#redo-log-文件写满了怎么办" class="sidebar-link">redo log 文件写满了怎么办？</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#为什么需要-binlog" class="sidebar-link">为什么需要 binlog ？</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#主从复制是怎么实现" class="sidebar-link">主从复制是怎么实现？</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#为什么需要两阶段提交" class="sidebar-link">为什么需要两阶段提交？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/79a23c/#索引" class="sidebar-link">索引</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#explain的时候-各个字段的含义" class="sidebar-link">explain的时候，各个字段的含义</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#连接mysql的协议" class="sidebar-link">连接mySQL的协议</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#select-type-列参数详解" class="sidebar-link">select_type 列参数详解</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#type参数" class="sidebar-link">type参数</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#索引为什么会加快查询速度" class="sidebar-link">索引为什么会加快查询速度</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#单列索引-与-多列索引" class="sidebar-link">单列索引 与 多列索引</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#唯一索引-与-非唯一索引" class="sidebar-link">唯一索引 与 非唯一索引</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#覆盖索引" class="sidebar-link">覆盖索引</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#聚簇索引和非聚簇索引" class="sidebar-link">聚簇索引和非聚簇索引</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#b-树" class="sidebar-link">B+树</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#mysql-8-0会将查询缓存删掉" class="sidebar-link">MySQL 8.0会将查询缓存删掉</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#索引-2" class="sidebar-link">索引</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#最左匹配原则" class="sidebar-link">最左匹配原则</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/79a23c/#sql-优化" class="sidebar-link">SQL 优化</a></li><li class="sidebar-sub-header level2"><a href="/pages/79a23c/#索引-3" class="sidebar-link">索引</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#索引分类" class="sidebar-link">索引分类</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#为什么使用索引会加快查询" class="sidebar-link">为什么使用索引会加快查询？</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#创建索引的注意的地方" class="sidebar-link">创建索引的注意的地方</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#索引哪些情况下会失效呢" class="sidebar-link">索引哪些情况下会失效呢？</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#索引是不是建的越多越好呢" class="sidebar-link">索引是不是建的越多越好呢？</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#为什么用b-树-而不用b树-二叉树-哈希" class="sidebar-link">为什么用B+树，而不用B树，二叉树，哈希</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/79a23c/#锁" class="sidebar-link">锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#mysql-有哪些锁" class="sidebar-link">MySQL 有哪些锁</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#mysql乐观锁和悲观锁" class="sidebar-link">MySQL乐观锁和悲观锁</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/79a23c/#事务" class="sidebar-link">事务</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#mysql中的acid通过什么来保证的呢" class="sidebar-link">MySQL中的ACID通过什么来保证的呢</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#mysql中的事务隔离级别如何保证" class="sidebar-link">MySQL中的事务隔离级别如何保证</a></li><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#mvcc是什么-解决了什么问题-如何实现" class="sidebar-link">MVCC是什么，解决了什么问题？如何实现？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/79a23c/#高可用-性能" class="sidebar-link">高可用/性能</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/79a23c/#为什么要读写分离" class="sidebar-link">为什么要读写分离</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>消息队列</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Mybatis</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/categories/?category=Java" title="分类" data-v-06225672>Java</a></li><li data-v-06225672><a href="/categories/?category=MySQL" title="分类" data-v-06225672>MySQL</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/jinhua0" target="_blank" title="作者" class="beLink" data-v-06225672>jinhua</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-07-08</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">MySQL<!----></h1>  <div class="theme-vdoing-content content__default"><h2 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h2> <h3 id="数据库三大范式"><a href="#数据库三大范式" class="header-anchor">#</a> 数据库三大范式</h3> <h3 id="varchar-与-char的区别"><a href="#varchar-与-char的区别" class="header-anchor">#</a> varchar 与 char的区别</h3> <h3 id="count-1-、count-与-count-列名-的区别"><a href="#count-1-、count-与-count-列名-的区别" class="header-anchor">#</a> count(1)、count(*) 与 count(列名) 的区别？</h3> <p>count(*) = count(1) &gt; count(主键) &gt; count(列名)</p> <h2 id="存储引擎"><a href="#存储引擎" class="header-anchor">#</a> 存储引擎</h2> <h3 id="innodb-和-mylsam-主要有什么区别"><a href="#innodb-和-mylsam-主要有什么区别" class="header-anchor">#</a> InnoDB 和 MylSAM 主要有什么区别？</h3> <ul><li>事务支持：MyISAM 不提供事务支持；InnoDB 提供事务支持事务，具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全特性。</li> <li>最小锁粒度：MyISAM 只支持表级锁，更新时会锁住整张表，导致其它查询和更新都会被阻塞 InnoDB 支持行级锁。</li> <li>索引类型：MyISAM 的索引为非聚簇索引，数据结构是 B 树；InnoDB 的索引是聚簇索引，数据结构是 B+树。</li> <li>外键支持：MyISAM 不支持外键；InnoDB 支持外键。</li></ul> <h2 id="日志"><a href="#日志" class="header-anchor">#</a> 日志</h2> <h3 id="undo-log-binlog-redo-log"><a href="#undo-log-binlog-redo-log" class="header-anchor">#</a> undo log , binlog , redo log</h3> <p>binlog、redo log 和 undo log 都是 MySQL 数据库中的日志文件，但它们记录的内容和用途不同。</p> <ul><li><p><strong>binlog</strong>：它用于记录数据库执行的写入性操作（不包括查询）信息，以二进制的形式保存在磁盘中。它是 MySQL 的逻辑日志，并且由 Server 层进行记录，使用任何存储引擎的 MySQL 数据库都会记录 binlog 日志。它主要用于主从复制和数据恢复。</p></li> <li><p><strong>redo log</strong>：它是 InnoDB 存储引擎层维护的，用于记录事务对数据页做了哪些修改。这样就能完美地解决性能问题了（相对而言文件更小并且是顺序IO）。它包括两部分：一个是内存中的日志缓冲（redo log buffer），另一个是磁盘上的日志文件（redo log file）。MySQL 每执行一条 DML 语句，先将记录写入 redo log buffer，后续某个时间点再一次性将多个操作记录写到 redo log file。这种先写日志，再写磁盘的技术就是 MySQL 里经常说到的 WAL（Write-Ahead Logging）技术。</p></li> <li><p><strong>undo log</strong>：它也是 InnoDB 存储引擎层维护的，用于在事务回滚时撤销已经完成的修改。它记录了事务执行前数据的原始值，当事务需要回滚时，可以利用 undo log 中的信息将数据恢复到事务执行前的状态</p></li></ul> <h3 id="什么叫dml语句"><a href="#什么叫dml语句" class="header-anchor">#</a> 什么叫DML语句</h3> <p>DML 是 Data Manipulation Language（数据操纵语言）的缩写。它是 SQL 语言的一个子集，用于检索、插入、更新和删除数据库中的数据。常见的 DML 语句包括 SELECT、INSERT、UPDATE 和 DELETE。</p> <h3 id="为什么需要-undo-log"><a href="#为什么需要-undo-log" class="header-anchor">#</a> 为什么需要 undo log？</h3> <ul><li>实现事务回滚，保障事务的原子性。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li> <li>实现 MVCC（多版本并发控制）关键因素之一。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li></ul> <h3 id="readview"><a href="#readview" class="header-anchor">#</a> ReadView</h3> <p>Read View是一个数据库的内部快照，该快照被用于InnoDB存储引擎中的MVCC机制。Read View记录了数据库在某个时刻的数据信息，用于实现快照读³。</p> <p>Read View会根据事务的隔离级别决定在某个事务开始时，该事务能看到什么信息。Read View包含了以下几个重要的信息：</p> <ul><li><code>m_low_limit_id</code>：该事务不应该看到任何大于等于这个值的事务ID所做的修改。</li> <li><code>m_up_limit_id</code>：该事务应该看到所有小于这个值的事务ID所做的修改。</li> <li><code>m_ids</code>：该事务开始时，活跃的读写事务ID的集合。</li> <li><code>m_creator_trx_id</code>：创建这个Read View的事务ID。</li></ul> <p>Read View通过比较记录中的事务ID和自身的信息，来判断记录是否对自己可见。具体的规则如下：</p> <ul><li>如果记录的事务ID小于<code>m_up_limit_id</code>，则说明记录是在该事务之前就已经提交了，对该事务可见。</li> <li>如果记录的事务ID大于等于<code>m_low_limit_id</code>，则说明记录是在该事务之后才提交了，对该事务不可见。</li> <li>如果记录的事务ID在<code>m_up_limit_id</code>和<code>m_low_limit_id</code>之间，但不在<code>m_ids</code>中，则说明记录是在该事务之前就已经提交了，但是在该事务开始时还没有提交，对该事务可见。</li> <li>如果记录的事务ID在<code>m_up_limit_id</code>和<code>m_low_limit_id</code>之间，并且在<code>m_ids</code>中，则说明记录是在该事务开始后才提交了，对该事务不可见。</li></ul> <p>举个例子，假设有以下几个并发执行的事务：</p> <table><thead><tr><th>事务ID</th> <th>隔离级别</th> <th>操作</th></tr></thead> <tbody><tr><td>1</td> <td>可重复读</td> <td>更新表A中id为1的记录</td></tr> <tr><td>2</td> <td>可重复读</td> <td>查询表A中id为1的记录</td></tr> <tr><td>3</td> <td>可重复读</td> <td>查询表A中id为1的记录</td></tr></tbody></table> <p>假设表A中id为1的记录最初是由事务0创建并提交的。那么，在不同的时间点，这些事务和记录会有如下情况：</p> <table><thead><tr><th>时间点</th> <th>记录中的事务ID</th> <th>1 的 Read View</th> <th>2 的 Read View</th> <th>3 的 Read View</th></tr></thead> <tbody><tr><td>t0</td> <td>0</td> <td>-</td> <td>-</td> <td>-</td></tr> <tr><td>t1（1 开始）</td> <td>0</td> <td>m_low_limit_id = 2, m_up_limit_id = 2, m_ids = {1}</td> <td>-</td> <td>-</td></tr> <tr><td>t2（2 开始）</td> <td>0</td> <td>m_low_limit_id = 2, m_up_limit_id = 2, m_ids = {1}</td> <td>m_low_limit_id = 3, m_up_limit_id = 3, m_ids = {1,2}</td> <td>-</td></tr> <tr><td>t3（3 开始）</td> <td>0</td> <td>m_low_limit_id = 2, m_up_limit_id = 2, m_ids = {1}</td> <td>m_low_limit_id = 3, m_up_limit_id = 3, m_ids = {1,2}</td> <td>m_low_limit_id = 4, m_up_limit_id = 4, m_ids = {1,2,3}</td></tr> <tr><td>t4（1 提交）</td> <td>1</td> <td>m_low_limit_id = 2, m_up_limit_id = 2, m_ids = {1}</td> <td>m_low_limit_id = 3, m_up_limit_id = 3, m_ids = {1,2}</td> <td>m_low_limit_id = 4, m_up_limit_id = 4, m_ids = {1,2,3}</td></tr></tbody></table> <p>根据上表，我们可以看到，在t4时刻，对于不同的Read View，记录是否可见的判断如下：</p> <ul><li>对于1的Read View，记录的事务ID（1）大于等于<code>m_low_limit_id</code>（2），对1不可见。</li> <li>对于2的Read View，记录的事务ID（1）在<code>m_up_limit_id</code>（3）和<code>m_low_limit_id</code>（3）之间，并且在<code>m_ids</code>中，对2不可见。</li> <li>对于3的Read View，记录的事务ID（1）在<code>m_up_limit_id</code>（4）和<code>m_low_limit_id</code>（4）之间，但不在<code>m_ids</code>中，对3可见。</li></ul> <h3 id="undo-log-是如何刷盘-持久化到磁盘-的"><a href="#undo-log-是如何刷盘-持久化到磁盘-的" class="header-anchor">#</a> undo log 是如何刷盘（持久化到磁盘）的？</h3> <p>buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。</p> <h3 id="为什么需要-buffer-pool"><a href="#为什么需要-buffer-pool" class="header-anchor">#</a> 为什么需要 Buffer Pool？</h3> <ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li> <li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li></ul> <h3 id="为什么需要-redo-log"><a href="#为什么需要-redo-log" class="header-anchor">#</a> 为什么需要 redo log ？</h3> <p>先写入redo log日志的，并且还没有将脏页数据更新到磁盘，但是redo log日志已经持久化，所以可以用redo log日志的内容在MySQL重启的时候，进行故障恢复，将数据恢复到最新的状态。</p> <h3 id="redo-log-文件写满了怎么办"><a href="#redo-log-文件写满了怎么办" class="header-anchor">#</a> redo log 文件写满了怎么办？</h3> <p>重做日志里面有两个大小相等的日志文件，以循环写的方式进行工作。先将文件日志的内容刷新到数据库，再redo log日志进行覆盖写。</p> <h3 id="为什么需要-binlog"><a href="#为什么需要-binlog" class="header-anchor">#</a> 为什么需要 binlog ？</h3> <p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。
而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用 redo log 来实现 crash-safe 能力。</p> <h3 id="主从复制是怎么实现"><a href="#主从复制是怎么实现" class="header-anchor">#</a> 主从复制是怎么实现？</h3> <p>MySQL 主从复制是通过 binlog 来实现的。在主库上，所有的增删改操作都会被记录在 binlog 中。当从库连接到主库时，它会主动从主库获取最新的 binlog 文件。然后把 binlog 存储到本地的 relay log 中，再执行 relay log 中的更新内容²。
MySQL 集群的主从复制过程梳理成 3 个阶段：</p> <ul><li>写入 Binlog：主库写 binlog 日志，提交事务，并更新本地存储数据。</li> <li>同步 Binlog：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li> <li>回放 Binlog：回放 binlog，并更新存储引擎中的数据。</li></ul> <h3 id="为什么需要两阶段提交"><a href="#为什么需要两阶段提交" class="header-anchor">#</a> 为什么需要两阶段提交？</h3> <p>如果binlog日志 和 redo log日志不同时刷盘的话，MySQL奔溃重启恢复的时候，就会出现主从数据不一致的情况。</p> <p>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p> <p>两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」：</p> <ul><li>准备阶段：协调者会问多个逻辑参与者，是否都准备，都准备好了的话，就可以做后面的事情了。</li> <li>提交阶段：如果多个逻辑参与者都准备好了，就开始做提交操作；如果哪一方没准备好，就要进行回退操作</li></ul> <p>比如说redo log 与 binlog之间的两阶段提交</p> <ul><li>第一阶段，InnoDB redo log 写盘，InnoDB 事务进入 prepare 状态。</li> <li>第二阶段，如果前面 prepare 成功，那么再继续将事务日志持久化到 binlog。如果持久化成功，那么 InnoDB 事务则进入 commit 状态，在 redo log 里面写一个 commit 记录。</li></ul> <h2 id="索引"><a href="#索引" class="header-anchor">#</a> 索引</h2> <h3 id="explain的时候-各个字段的含义"><a href="#explain的时候-各个字段的含义" class="header-anchor">#</a> explain的时候，各个字段的含义</h3> <p><code>EXPLAIN</code> 语句用于显示 MySQL 如何执行 <code>SELECT</code> 语句。它返回一张表，其中每一行表示查询执行计划中的一个步骤。下面是一些常见的 <code>EXPLAIN</code> 输出列及其含义：</p> <ul><li><strong>id</strong>：查询的标识符，相同的 <code>id</code> 表示同一个查询块。</li> <li><strong>select_type</strong>：查询的类型，如 SIMPLE（简单查询）、PRIMARY（主查询）、SUBQUERY（子查询）等。</li> <li><strong>table</strong>：查询所涉及的表。</li> <li><strong>partitions</strong>：匹配的分区。</li> <li><strong>type</strong>：连接类型，表示 MySQL 如何查找表中的行。常见的类型有 ALL（全表扫描）、index（索引扫描）、range（范围扫描）、ref（非唯一索引查找）等。</li> <li><strong>possible_keys</strong>：可能用到的索引。</li> <li><strong>key</strong>：实际使用的索引。</li> <li><strong>key_len</strong>：使用的索引的长度。</li> <li><strong>ref</strong>：哪些列或常量与 <code>key</code> 一起被用于查找索引。</li> <li><strong>rows</strong>：MySQL 认为需要检查的行数。</li> <li><strong>filtered</strong>：按表条件过滤后剩余的行数百分比。</li> <li><strong>Extra</strong>：额外信息，如 Using index（使用覆盖索引）、Using where（使用 WHERE 过滤）等。</li></ul> <p>在查看 <code>EXPLAIN</code> 输出时，您应该关注以下几个参数：</p> <ol><li><p><strong>type</strong>：连接类型应尽可能靠前，避免使用 ALL 和 index 类型。
其中，<strong>all</strong>表示全表扫描，MySQL会扫描整个表来找到匹配的行。而<strong>index</strong>则表示全索引扫描，MySQL会扫描整个索引来找到匹配的行。这两种类型都是效率较低的连接类型，应尽量避免使用。</p></li> <li><p><strong>rows</strong>：检查的行数应尽量少。</p></li> <li><p><strong>Extra</strong>：避免出现 Using temporary 和 Using filesort。出现这两种意味着没有使用到索引。</p></li></ol> <h3 id="连接mysql的协议"><a href="#连接mysql的协议" class="header-anchor">#</a> 连接mySQL的协议</h3> <p>连接 MySQL 是基于 <strong>TCP/IP 协议</strong>的，这是一种在互联网上广泛使用的通信协议，可以实现不同主机之间的数据传输。MySQL 客户端和服务器之间的通信协议是有状态的，也就是说，它们会维护一个连接状态，并根据不同的状态进行不同的操作。</p> <p>为什么要使用 TCP/IP 协议呢？主要有以下几个原因：</p> <ul><li>TCP/IP 协议是一种可靠的协议，它可以保证数据包的有序、完整和正确地到达目的地。</li> <li>TCP/IP 协议是一种通用的协议，它可以支持不同的操作系统、网络设备和应用程序之间的通信。</li> <li>TCP/IP 协议是一种灵活的协议，它可以支持不同的网络拓扑结构和传输媒介，如以太网、无线网等。</li> <li>TCP/IP 协议是一种可扩展的协议，它可以支持不断增长的网络规模和需求。</li></ul> <h3 id="select-type-列参数详解"><a href="#select-type-列参数详解" class="header-anchor">#</a> select_type 列参数详解</h3> <p>select_type 列表示查询的类型，主要用来区分简单查询、联合查询、子查询等复杂查询。select_type 列的常见值有以下几种：</p> <ul><li><strong>SIMPLE</strong>：简单的 select 查询，查询中不包含子查询或者 UNION。</li> <li><strong>PRIMARY</strong>：查询中若包含任何复杂的子部分，最外层的查询则被标记为 PRIMARY。</li> <li><strong>SUBQUERY</strong>：在 select 或者 where 列表中包含了子查询。</li> <li><strong>DERIVED</strong>：在 from 列表中包含的子查询会被标记为 DERIVED，MySQL 会递归地执行这些子查询，然后把结果放到临时表中。</li> <li><strong>UNION</strong>：若第二个 select 语句出现在 UNION 之后，则被标记为 UNION。若 UNION 包含在 from 子句的子查询中，外层 select 则被标记为 DERIVED。</li> <li><strong>UNION RESULT</strong>：从 UNION 表获取结果的 select。</li></ul> <p>举例说明：</p> <ul><li>简单查询：</li></ul> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>select_type 为 SIMPLE。</p> <ul><li>联合查询：</li></ul> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student
<span class="token keyword">union</span> <span class="token keyword">all</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> teacher<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>select_type 为 DERIVED 和 UNION。</p> <ul><li>子查询：</li></ul> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student
<span class="token keyword">where</span> school_id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> school <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>select_type 为 PRIMARY 和 SUBQUERY。</p> <h3 id="type参数"><a href="#type参数" class="header-anchor">#</a> type参数</h3> <p>type 列表示 MySQL 在表中查找行时使用的访问类型。它是 EXPLAIN 输出中最重要的列之一，因为它可以帮助您了解查询的性能瓶颈。type 列的常见值有以下几种，按性能从好到差排列：</p> <ul><li><strong>system</strong>：表只有一行记录（等于系统表）。这是 const 类型的特殊情况。</li> <li><strong>const</strong>：表最多有一个匹配行，它在查询执行时就被读取。因为只有一行，所以速度非常快。</li> <li><strong>eq_ref</strong>：对于每个来自前面表的行组合，从该表中读取一行。这可能是最好的联接类型，除了 const 类型。</li> <li><strong>ref</strong>：对于每个来自前面表的行组合，所有匹配的行将从该表中读取。ref 是使用非唯一索引或唯一索引的前缀进行查找的。</li> <li><strong>range</strong>：只检索给定范围内的行，使用索引来选择行。</li> <li><strong>index</strong>：全索引扫描，与 ALL 类型类似，只是按索引次序进行扫描，而不是按行。如果额外显示 Using index，则说明使用了覆盖索引。</li> <li><strong>ALL</strong>：全表扫描，MySQL 需要从头到尾读取整张表来找到相关的行。</li></ul> <p>举例说明：</p> <ul><li>const 类型：</li></ul> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>type 为 const。</p> <ul><li>eq_ref 类型：</li></ul> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student<span class="token punctuation">,</span> school <span class="token keyword">where</span> student<span class="token punctuation">.</span>school_id <span class="token operator">=</span> school<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>type 为 ALL 和 eq_ref。</p> <ul><li>ref 类型：</li></ul> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> school_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>type 为 ref。</p> <ul><li>range 类型：</li></ul> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">between</span> <span class="token number">1</span> <span class="token operator">and</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>type 为 range。</p> <h3 id="索引为什么会加快查询速度"><a href="#索引为什么会加快查询速度" class="header-anchor">#</a> 索引为什么会加快查询速度</h3> <p>索引可以加快查询速度，因为它可以帮助数据库快速定位到符合查询条件的记录。没有索引时，数据库需要进行全表扫描，即逐行检查每条记录，以确定哪些记录符合查询条件。这种方式非常耗时，特别是当表中的数据量很大时。</p> <p>而有了索引后，数据库可以使用索引来快速定位到符合查询条件的记录。索引通常使用 B-Tree 数据结构来存储数据，这种数据结构可以让数据库快速找到指定范围内的数据。因此，使用索引可以大大减少数据库需要检查的记录数，从而加快查询速度。</p> <p>举个例子，假设我们有一个学生表，其中包含学生的姓名、年龄和学校。如果我们要查询来自 A 学校的所有学生，可以执行以下 SQL 语句：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> school <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果没有在 school 列上创建索引，那么数据库需要进行全表扫描，逐行检查每条记录，以确定哪些学生来自 A 学校。这种方式非常耗时。</p> <p>但是如果我们在 school 列上创建了索引，那么数据库就可以使用这个索引来快速定位到来自 A 学校的所有学生。这样就不需要进行全表扫描了，查询速度会大大提高。</p> <h3 id="单列索引-与-多列索引"><a href="#单列索引-与-多列索引" class="header-anchor">#</a> 单列索引 与 多列索引</h3> <p>唯一索引和非唯一索引是根据索引列的唯一性来分类的。</p> <ul><li><strong>唯一索引</strong>：唯一索引是指索引列中的值不能重复。这意味着每行记录都必须拥有唯一的索引值。唯一索引可以加快数据检索速度，并强制数据的唯一性。</li></ul> <p>例如，假设我们有一个学生表，其中包含学生的学号、姓名和年龄。我们可以在学号列上创建一个唯一索引，因为每个学生都应该拥有唯一的学号。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> idx_student_id <span class="token keyword">ON</span> student <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这样，在执行查询时，如果我们需要根据学号查找学生，MySQL 可以使用这个唯一索引来加快查询速度。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><strong>非唯一索引</strong>：非唯一索引，也称为普通索引，是指索引列中的值可以重复。这意味着多行记录可以拥有相同的索引值。非唯一索引可以加快数据检索速度，但不会强制数据的唯一性。</li></ul> <p>例如，假设我们有一个学生表，其中包含学生的姓名、年龄和学校。我们可以在学校列上创建一个非唯一索引，因为多个学生可能来自同一所学校。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_school <span class="token keyword">ON</span> student <span class="token punctuation">(</span>school<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这样，在执行查询时，如果我们需要根据学校筛选学生，MySQL 可以使用这个非唯一索引来加快查询速度。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> school <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="唯一索引-与-非唯一索引"><a href="#唯一索引-与-非唯一索引" class="header-anchor">#</a> 唯一索引 与 非唯一索引</h3> <p>唯一索引和非唯一索引是根据索引列的唯一性来分类的。</p> <ul><li><strong>唯一索引</strong>：唯一索引是指索引列中的值不能重复。这意味着每行记录都必须拥有唯一的索引值。唯一索引可以加快数据检索速度，并强制数据的唯一性。</li></ul> <p>例如，假设我们有一个学生表，其中包含学生的学号、姓名和年龄。我们可以在学号列上创建一个唯一索引，因为每个学生都应该拥有唯一的学号。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> idx_student_id <span class="token keyword">ON</span> student <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这样，在执行查询时，如果我们需要根据学号查找学生，MySQL 可以使用这个唯一索引来加快查询速度。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><strong>非唯一索引</strong>：非唯一索引，也称为普通索引，是指索引列中的值可以重复。这意味着多行记录可以拥有相同的索引值。非唯一索引可以加快数据检索速度，但不会强制数据的唯一性。</li></ul> <p>例如，假设我们有一个学生表，其中包含学生的姓名、年龄和学校。我们可以在学校列上创建一个非唯一索引，因为多个学生可能来自同一所学校。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_school <span class="token keyword">ON</span> student <span class="token punctuation">(</span>school<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这样，在执行查询时，如果我们需要根据学校筛选学生，MySQL 可以使用这个非唯一索引来加快查询速度。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> school <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="覆盖索引"><a href="#覆盖索引" class="header-anchor">#</a> 覆盖索引</h3> <p>覆盖索引是指索引包含了查询所需的所有数据列，而不需要再回表查询原始数据。覆盖索引可以大大提高查询效率，因为它可以减少磁盘 IO 操作，只需要访问索引即可。</p> <p>例如，假设我们有一个学生表，其中包含学生的姓名、年龄和学校。我们可以在姓名和年龄两列上创建一个多列索引，以加快基于姓名和年龄的查询速度。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_name_age <span class="token keyword">ON</span> student <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这样，在执行查询时，如果我们只需要查询姓名和年龄两列，MySQL 可以使用这个多列索引作为覆盖索引来加快查询速度。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span> age <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在 EXPLAIN 输出中，如果显示了 Using index，说明使用了覆盖索引。</p> <h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="header-anchor">#</a> 聚簇索引和非聚簇索引</h3> <p>聚簇索引和非聚簇索引是根据数据的物理存储方式来分类的。</p> <ul><li><strong>聚簇索引</strong>：聚簇索引是指数据行的物理顺序与索引的逻辑顺序相同。也就是说，索引和数据存储在一起，按照索引的顺序存储。聚簇索引可以加快<strong>范围查询</strong>的速度，因为相关的数据行在磁盘上是相邻的。</li></ul> <p>例如，在 InnoDB 存储引擎中，主键索引就是聚簇索引。假设我们有一个学生表，其中包含学生的学号、姓名和年龄。学号列是主键，因此它是聚簇索引。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> student <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    age <span class="token keyword">INT</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这样，在执行查询时，如果我们需要根据学号范围筛选学生，MySQL 可以使用这个聚簇索引来加快查询速度。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">BETWEEN</span> <span class="token number">1</span> <span class="token operator">AND</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><strong>非聚簇索引</strong>：非聚簇索引是指数据行的物理顺序与索引的逻辑顺序不同。也就是说，索引和数据分开存储，索引中只包含数据行的指针。非聚簇索引可以加快<strong>等值查询</strong>的速度，但范围查询可能会比较慢。</li></ul> <p>例如，在 MyISAM 存储引擎中，所有索引都是非聚簇索引。假设我们有一个学生表，其中包含学生的学号、姓名和年龄。我们可以在姓名列上创建一个非聚簇索引，以加快基于姓名的查询速度。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> student <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span><span class="token punctuation">,</span>
    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    age <span class="token keyword">INT</span><span class="token punctuation">,</span>
    <span class="token keyword">INDEX</span> idx_name <span class="token punctuation">(</span>name<span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span>MyISAM<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这样，在执行查询时，如果我们需要根据姓名查找学生，MySQL 可以使用这个非聚簇索引来加快查询速度。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="b-树"><a href="#b-树" class="header-anchor">#</a> B+树</h3> <p>B+树是一种多路平衡查找树，它的每个节点可以有多个子节点。在B+树中，所有的数据都存储在叶子节点中，而非叶子节点只存储键值和指向子节点的指针。</p> <p>键值是用来索引数据的，它们将数据分成不同的区间。每个非叶子节点中的键值都对应着一个子节点，指示了该子节点中所有数据的范围。例如，假设我们有一个非叶子节点，其中包含两个键值10和20，以及三个指针分别指向三个子节点。那么第一个子节点中所有数据都小于10，第二个子节点中所有数据都在10和20之间，第三个子节点中所有数据都大于20。</p> <p>数据是实际存储在叶子节点中的记录。每个叶子节点包含一定数量的数据记录，这些记录按照键值排序。例如，在上面的例子中，第一个叶子节点可能包含键值为1、3、5、7、9的记录，第二个叶子节点可能包含键值为11、13、15、17、19的记录，第三个叶子节点可能包含键值为21、23、25、27、29的记录。</p> <p>这种结构使得B+树能够快速定位数据。当我们查找一个特定键值的记录时，我们从根节点开始，通过比较键值和指针来确定应该进入哪个子节点。然后重复这个过程直到到达叶子节点，在叶子节点中找到对应的数据记录。</p> <h3 id="mysql-8-0会将查询缓存删掉"><a href="#mysql-8-0会将查询缓存删掉" class="header-anchor">#</a> MySQL 8.0会将查询缓存删掉</h3> <p>MySQL 8.0 版本中删除了查询缓存功能。这是因为查询缓存的效果取决于缓存的命中率，只有命中缓存的查询效果才能有改善，因此无法预测其性能。此外，查询缓存的另一个大问题是它受到单个互斥锁的保护。在具有多个内核的服务器上，大量查询会导致大量的互斥锁争用。通过基准测试发现，大多数工作负载最好禁用查询缓存。</p> <h3 id="索引-2"><a href="#索引-2" class="header-anchor">#</a> 索引</h3> <p>索引是一种数据结构，它可以帮助我们快速地查找、排序、分组或者聚合数据。索引的原理类似于书籍的目录，它可以让我们根据关键字或者范围来定位数据的位置，而不需要扫描整个数据集。</p> <p>举个例子，假设我们有一个学生表，包含学号、姓名、年龄、性别等字段。如果我们想要查询年龄为18岁的学生，我们可以在年龄字段上创建一个索引。这样，当我们执行查询时，就可以直接在索引中找到年龄为18岁的学生的位置，然后根据位置去读取对应的记录。这样就避免了扫描整个表，提高了查询效率。</p> <h3 id="最左匹配原则"><a href="#最左匹配原则" class="header-anchor">#</a> 最左匹配原则</h3> <p>最左匹配原则，也称为最左前缀原则，是指在使用联合索引进行查询时，必须满足索引的最左列的查询条件才能使用索引。</p> <p>举个例子，假设我们有一个学生表，包含学号、姓名、年龄、性别等字段。我们在姓名和年龄两个字段上创建了一个联合索引。那么，当我们执行以下查询时，就可以使用索引：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> students <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">'张三'</span> <span class="token operator">AND</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这是因为查询条件中包含了索引的最左列（姓名）的查询条件。</p> <p>但是，如果我们执行以下查询，则无法使用索引：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> students <span class="token keyword">WHERE</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这是因为查询条件中没有包含索引的最左列（姓名）的查询条件。</p> <p>总之，最左匹配原则是指在使用联合索引进行查询时，必须满足索引的最左列的查询条件才能使用索引。</p> <h2 id="sql-优化"><a href="#sql-优化" class="header-anchor">#</a> SQL 优化</h2> <ul><li>看是否走了索引吧，避免全表扫描</li> <li>加适当的索引，比如利用覆盖索引等等</li> <li>分页优化</li></ul> <h2 id="索引-3"><a href="#索引-3" class="header-anchor">#</a> 索引</h2> <h3 id="索引分类"><a href="#索引分类" class="header-anchor">#</a> 索引分类</h3> <h3 id="为什么使用索引会加快查询"><a href="#为什么使用索引会加快查询" class="header-anchor">#</a> 为什么使用索引会加快查询？</h3> <h3 id="创建索引的注意的地方"><a href="#创建索引的注意的地方" class="header-anchor">#</a> 创建索引的注意的地方</h3> <ul><li>索引应该建在查询应用频繁的字段</li> <li>索引的个数应该适量</li> <li>区分度低的字段，例如性别，不要建索引。</li> <li>频繁更新的值，不要作为主键或者索引</li></ul> <h3 id="索引哪些情况下会失效呢"><a href="#索引哪些情况下会失效呢" class="header-anchor">#</a> 索引哪些情况下会失效呢？</h3> <ul><li>like 通配符可能导致索引失效。</li> <li>联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。</li> <li>对索引列运算（如，+、-、*、/），索引失效。</li></ul> <h3 id="索引是不是建的越多越好呢"><a href="#索引是不是建的越多越好呢" class="header-anchor">#</a> 索引是不是建的越多越好呢？</h3> <ul><li>索引会占据磁盘空间</li> <li>索引虽然会提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改操作，MySQL 不仅要保存数据，还有保存或者更新对应的索引文件。</li></ul> <h3 id="为什么用b-树-而不用b树-二叉树-哈希"><a href="#为什么用b-树-而不用b树-二叉树-哈希" class="header-anchor">#</a> 为什么用B+树，而不用B树，二叉树，哈希</h3> <h2 id="锁"><a href="#锁" class="header-anchor">#</a> 锁</h2> <h3 id="mysql-有哪些锁"><a href="#mysql-有哪些锁" class="header-anchor">#</a> MySQL 有哪些锁</h3> <ul><li>表级锁
<ul><li>表锁
<ul><li>表级别共享锁就是读锁</li> <li>表级别独占锁就是写锁</li></ul></li> <li>元数据锁(MDL)
<ul><li>对一张表进行 CRUD 操作时，加的是 MDL 读锁；</li> <li>对一张表做结构变更操作的时候，加的是 MDL 写锁；</li></ul></li> <li>意向锁
<ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li> <li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li> <li>意向锁的目的是为了快速判断表里是否有记录被加锁。</li></ul></li> <li>AUTO-INC 锁
<ul><li>插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 AUTO-INC 锁实现的。</li></ul></li></ul></li> <li>行级锁
<ul><li>Record Lock
<ul><li>有了记录锁，事务就可以只锁定需要修改的行，而不是整张表。这样，其他事务就可以继续访问该表中未被锁定的行。这大大提高了数据库系统的并发性能。</li></ul></li> <li>Gap Lock
<ul><li>为了防止幻读的发生，数据库系统可以使用 Gap Lock 对索引记录之间的间隙进行锁定。在上面的例子中，如果数据库系统使用了 Gap Lock，那么当事务 2 尝试插入新记录时，它将被阻塞，直到事务 1 提交或回滚。</li></ul></li> <li>Next-Key Lock
<ul><li>记录锁 + 间隙锁</li></ul></li> <li>插入意向锁
<ul><li>如果一个区间gap里面被上了间隙锁，当有事务想在这个gap里面插入一条记录的话，就会获取一个插入意向锁，并等待加入gap锁的事务提交</li></ul></li></ul></li></ul> <h3 id="mysql乐观锁和悲观锁"><a href="#mysql乐观锁和悲观锁" class="header-anchor">#</a> MySQL乐观锁和悲观锁</h3> <ul><li>悲观锁
数据库中的行锁，表锁，读锁，写锁均为悲观锁。</li> <li>乐观锁
乐观锁通常是通过在表中增加一个版本(version)或时间戳(timestamp)来实现，其中，版本最为常用。</li></ul> <h2 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h2> <h3 id="mysql中的acid通过什么来保证的呢"><a href="#mysql中的acid通过什么来保证的呢" class="header-anchor">#</a> MySQL中的ACID通过什么来保证的呢</h3> <p>MySQL数据库的ACID是通过多种方式来保证的。ACID是指原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</p> <ul><li>原子性：MySQL通过使用undo log来保证原子性。当事务对数据库进行修改时，InnoDB会生成对应的undo log。如果事务执行失败或调用了rollback，导致事务需要回滚，InnoDB引擎会根据undo log中的记录，将数据回滚到之前的样子。</li> <li>一致性：一致性是事务的最终目的，它需要数据库层面和应用层面共同保证。MySQL底层通过两阶段提交事务保证了事务持久化时的一致性。</li> <li>隔离性：MySQL通过使用锁机制和MVCC机制来保证隔离性。锁机制可以保证事务间的读写隔离，而MVCC机制可以保证事务间的写操作隔离。</li> <li>持久性：MySQL通过使用redo log来保证持久性。当事务提交时，redo log会被刷盘。这样，即使MySQL出现宕机，也可以从磁盘中读取redo log进行数据恢复，从而保证了事务的持久性。</li></ul> <h3 id="mysql中的事务隔离级别如何保证"><a href="#mysql中的事务隔离级别如何保证" class="header-anchor">#</a> MySQL中的事务隔离级别如何保证</h3> <ul><li>事务隔离级别是指在并发访问数据库时，一个事务对数据所做的修改，是否能够被其他事务看到。SQL标准定义了四种隔离级别，分别是读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。</li> <li>不同的隔离级别有不同的实现方式，主要涉及到锁和多版本并发控制（MVCC）两种机制。锁是一种悲观并发控制的方法，通过对数据加上共享锁或排他锁来防止其他事务的干扰。MVCC是一种乐观并发控制的方法，通过为每个数据行保存多个版本来实现一致性非锁定读。</li> <li>在MySQL中，InnoDB存储引擎使用锁和MVCC来实现不同的隔离级别。具体来说：
<ul><li>读未提交：这是最低的隔离级别，不加任何锁，也不使用MVCC，直接读取最新的数据行，可能会出现脏读、不可重复读和幻读等问题。</li> <li>读已提交：这个隔离级别使用MVCC来实现一致性非锁定读，每次查询都会生成一个新的快照，只能看到已经提交的数据修改。这样可以避免脏读，但是可能会出现不可重复读和幻读等问题。</li> <li>可重复读：这是MySQL的默认隔离级别，也使用MVCC来实现一致性非锁定读，但是每个事务只会生成一个快照，多次查询都会看到同样的数据。这样可以避免脏读和不可重复读，但是可能会出现幻读等问题。为了解决幻读问题，InnoDB还引入了间隙锁（Gap Lock），即对查询范围内的空间加上共享锁或排他锁，防止其他事务插入新的数据行³。</li> <li>串行化：这是最高的隔离级别，对所有的查询都加上排他锁，使得所有的事务都必须串行执行。这样可以避免所有的并发问题，但是性能会受到很大影响。</li></ul></li></ul> <h3 id="mvcc是什么-解决了什么问题-如何实现"><a href="#mvcc是什么-解决了什么问题-如何实现" class="header-anchor">#</a> MVCC是什么，解决了什么问题？如何实现？</h3> <ul><li>MVCC是一种并发控制的方法，全称是Multi-Version Concurrency Control，即多版本并发控制。它主要是为了提高数据库的并发性能，解决事务之间的读写冲突问题³⁴。</li> <li>MVCC的基本思想是，每个数据行都有多个版本，每个版本都有一个时间戳或者事务ID来标识。当一个事务要读取一个数据行时，它会根据自己的时间戳或者事务ID来选择合适的版本，而不会被其他事务的修改所影响。当一个事务要修改一个数据行时，它会生成一个新的版本，并更新时间戳或者事务ID，而不会覆盖原来的版本。</li> <li>MVCC的实现方式有不同的变体，但一般都包括以下几个步骤：
<ul><li>为每个数据行添加两个隐藏字段，分别记录该行创建时的时间戳或者事务ID（简称创建ID），以及该行删除时的时间戳或者事务ID（简称删除ID）。初始时，创建ID为当前事务的ID，删除ID为空。</li> <li>当一个事务要读取一个数据行时，它会检查该行的创建ID和删除ID，如果满足以下条件，则认为该行对该事务可见，否则认为该行对该事务不可见：
<ul><li>创建ID小于或等于该事务的ID，并且删除ID为空或者大于该事务的ID。</li> <li>创建ID是已提交事务的ID，并且删除ID为空或者是未提交事务的ID。</li></ul></li> <li>当一个事务要修改一个数据行时，它会先复制该行，并生成一个新的版本。然后将新版本的创建ID设为当前事务的ID，并将旧版本的删除ID设为当前事务的ID。这样就保证了旧版本对其他事务不可见，而新版本只对当前事务可见。</li> <li>当一个事务要删除一个数据行时，它只需要将该行的删除ID设为当前事务的ID即可。这样就保证了该行对其他事务不可见，而对当前事务仍然可见。</li> <li>当一个事务提交或回滚时，它会根据自己的操作类型和结果来更新数据行的创建ID和删除ID。如果是提交操作，则将创建ID和删除ID都设为已提交状态；如果是回滚操作，则将创建ID和删除ID都设为空状态。</li></ul></li></ul> <h2 id="高可用-性能"><a href="#高可用-性能" class="header-anchor">#</a> 高可用/性能</h2> <h3 id="为什么要读写分离"><a href="#为什么要读写分离" class="header-anchor">#</a> 为什么要读写分离</h3> <p>通过使用读写分离，可以将读操作分发到多个从服务器上执行，而写操作仍然在主服务器上执行。这样，主服务器只需要处理写操作，而从服务器只需要处理读操作。这可以有效减轻主服务器的压力，提高数据库系统的性能。</p></div></div>  <div class="page-edit"><!----> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/2b3d9d/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Redis</div></a> <a href="/pages/a3c479/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">计算机网络</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/2b3d9d/" class="prev">Redis</a></span> <span class="next"><a href="/pages/a3c479/">计算机网络</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/d2b13d/"><div>
            实习技术
            <!----></div></a> <span class="date">08-24</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/39be8a/"><div>
            sql
            <!----></div></a> <span class="date">07-28</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/4375ac/"><div>
            git命令
            <!----></div></a> <span class="date">07-26</span></dt></dl> <dl><dd></dd> <dt><a href="/archives" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://www.zhihu.com/people/zhi-qing-72-50" title="知乎" target="_blank" class="iconfont icon-zhihu"></a><a href="https://github.com/jinhua0" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://space.bilibili.com/352135891?spm_id_from=333.337.0.0" title="blibli" target="_blank" class="iconfont icon-bilibili"></a><a href="er2578912608@163.com" title="邮箱" target="_blank" class="iconfont icon-youjian"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2023
    <span>Evan Xu | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.7087f587.js" defer></script><script src="/assets/js/2.e7663ce2.js" defer></script><script src="/assets/js/13.af686786.js" defer></script>
  </body>
</html>
