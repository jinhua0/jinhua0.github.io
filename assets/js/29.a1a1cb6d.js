(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{356:function(v,_,a){"use strict";a.r(_);var t=a(4),r=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"负载均衡"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡"}},[v._v("#")]),v._v(" 负载均衡")]),v._v(" "),_("h3",{attrs:{id:"什么是nginx-为什么要用nginx-nginx有哪些优势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是nginx-为什么要用nginx-nginx有哪些优势"}},[v._v("#")]),v._v(" 什么是Nginx,为什么要用Nginx,Nginx有哪些优势")]),v._v(" "),_("p",[v._v("Nginx 是一个高性能的 HTTP 和反向代理 web 服务器。\nNginx 优势：")]),v._v(" "),_("ul",[_("li",[v._v("高并发连接：Nginx 能够支持数以万计的并发连接")]),v._v(" "),_("li",[v._v("配置使用简单\n总结 就是性能高、稳定。")])]),v._v(" "),_("h3",{attrs:{id:"为什么nginx支持这么高的并发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么nginx支持这么高的并发"}},[v._v("#")]),v._v(" 为什么Nginx支持这么高的并发")]),v._v(" "),_("ul",[_("li",[v._v("事件驱动，IO多路复用的")]),v._v(" "),_("li",[v._v("多线程")])]),v._v(" "),_("h3",{attrs:{id:"正向代理、反向代理区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#正向代理、反向代理区别"}},[v._v("#")]),v._v(" 正向代理、反向代理区别")]),v._v(" "),_("p",[v._v("正向代理： 客户端的代理\n反向代理： 服务端的代理")]),v._v(" "),_("h3",{attrs:{id:"nginx是如何工作的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nginx是如何工作的"}},[v._v("#")]),v._v(" Nginx是如何工作的")]),v._v(" "),_("p",[v._v("Nginx一般启动一个master进程 和 多个worker进程，master进程负责管理worker进程，worker进程负责处理客户端请求。")]),v._v(" "),_("h3",{attrs:{id:"nginx-压缩了解吗-如何开启压缩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nginx-压缩了解吗-如何开启压缩"}},[v._v("#")]),v._v(" Nginx 压缩了解吗，如何开启压缩？")]),v._v(" "),_("p",[v._v("gzip压缩文件，节省带宽，提高传输效率")]),v._v(" "),_("h3",{attrs:{id:"nginx-有哪些负载均衡策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nginx-有哪些负载均衡策略"}},[v._v("#")]),v._v(" Nginx 有哪些负载均衡策略")]),v._v(" "),_("ol",[_("li",[v._v("轮询")]),v._v(" "),_("li",[v._v("IP哈希")]),v._v(" "),_("li",[v._v("最小连接数")]),v._v(" "),_("li",[v._v("权重weight")])]),v._v(" "),_("h3",{attrs:{id:"nginx-限流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nginx-限流"}},[v._v("#")]),v._v(" Nginx 限流")]),v._v(" "),_("ol",[_("li",[v._v("控制速率")]),v._v(" "),_("li",[v._v("控制并发连接数")])]),v._v(" "),_("h2",{attrs:{id:"kafka"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kafka"}},[v._v("#")]),v._v(" Kafka")]),v._v(" "),_("h3",{attrs:{id:"kafka如何保证分区顺序的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kafka如何保证分区顺序的"}},[v._v("#")]),v._v(" Kafka如何保证分区顺序的")]),v._v(" "),_("p",[v._v("kafka的分区 是 基于日志文件 实现的， 消息按照它们的到来顺序写入日志文件")]),v._v(" "),_("h3",{attrs:{id:"kafka高性能的原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kafka高性能的原因"}},[v._v("#")]),v._v(" Kafka高性能的原因")]),v._v(" "),_("ul",[_("li",[v._v("零拷贝，不需要把数据从内核缓存区拷贝到用户空间")]),v._v(" "),_("li",[v._v("数据压缩，传输的数据进行压缩，减少传输数据量")]),v._v(" "),_("li",[v._v("Kafka 异步操作")])]),v._v(" "),_("h3",{attrs:{id:"kafka高可用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kafka高可用"}},[v._v("#")]),v._v(" Kafka高可用")]),v._v(" "),_("ul",[_("li",[v._v("副本 机制 ： 分区有多个副本，分区分布在多个broker，某个broker故障，数据从其它broker恢复(数据备份)")]),v._v(" "),_("li",[v._v("ISR 机制 ： 维护一个 leader副本 同步分区副本的集合，只有ISR集合里的才可以被选为leader")]),v._v(" "),_("li",[v._v("ACK 机制 ： 对应分区 如果写入成功消息的话，就会发送ACK确认信息")])]),v._v(" "),_("h3",{attrs:{id:"kafka如何保证数据不丢失"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kafka如何保证数据不丢失"}},[v._v("#")]),v._v(" Kafka如何保证数据不丢失")]),v._v(" "),_("ul",[_("li",[v._v("持久化日志")]),v._v(" "),_("li",[v._v("副本机制")]),v._v(" "),_("li",[v._v("ACK机制")])]),v._v(" "),_("h3",{attrs:{id:"kafka-消息投递有且仅有一次语义怎么实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kafka-消息投递有且仅有一次语义怎么实现"}},[v._v("#")]),v._v(" Kafka 消息投递有且仅有一次语义怎么实现")]),v._v(" "),_("p",[v._v("Kafka 通过事务机制可以实现对多个 topic 的多个 partition 的原子性的写入，即处于同一个事务内的所有消息，不管最终需要落地到哪个 topic 的哪个 partition, 最终结果都是要么全部写成功，要么全部写失败（Atomic multi-partition writes）。\n就比如说，下单数据，支付成功 与 库存扣减消息，这两个消息应该是原子操作的，所以得放到事务里。")]),v._v(" "),_("h3",{attrs:{id:"kafka消息消费的实时性如何"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kafka消息消费的实时性如何"}},[v._v("#")]),v._v(" Kafka消息消费的实时性如何")]),v._v(" "),_("ul",[_("li",[v._v("Kafka消费方是 拉取的方式获取消息的，消费方可以控制消费速率")]),v._v(" "),_("li",[v._v("Kakfa消费方消费消息的时候，其实可以并行的消费，加快消费速率")]),v._v(" "),_("li",[v._v("Kafka 可以设置消费组， 数据量大的时候 可以消费组消费Topic不同分区的消息")])]),v._v(" "),_("h3",{attrs:{id:"kafka异步流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kafka异步流程"}},[v._v("#")]),v._v(" Kafka异步流程")]),v._v(" "),_("p",[v._v("在 Kafka 中，生产者发送消息的过程是异步的。这意味着当生产者调用 "),_("code",[v._v("send")]),v._v(" 方法时，消息会被存储在一个缓冲区中，而不是立即发送到服务器。这样，生产者可以继续执行其他操作，而不必等待消息发送完成。")]),v._v(" "),_("p",[v._v("Kafka 生产者端有两个线程：主线程和 sender IO 线程。当用户调用 "),_("code",[v._v("send")]),v._v(" 方法时，消息会被缓存到 RecordAccumulator 中，"),_("code",[v._v("send")]),v._v(" 方法会立即返回，此时并不能确定消息是否真正发送到 broker。sender IO 线程会不断轮询 RecordAccumulator，满足一定条件后就进行真正的网络 IO 发送，使用的是异步非阻塞的 NIO。")]),v._v(" "),_("p",[v._v("当缓冲区中的消息数量达到一定阈值（由 "),_("code",[v._v("batch.size")]),v._v(" 参数控制）或者距离上一次发送的时间超过一定间隔（由 "),_("code",[v._v("linger.ms")]),v._v(" 参数控制）时，sender IO 线程会将缓冲区中的消息批量发送到服务器。此外，用户也可以调用 "),_("code",[v._v("flush")]),v._v(" 方法来强制发送缓冲区中的所有消息。")]),v._v(" "),_("p",[v._v("总之，在 Kafka 中，生产者发送消息的过程是异步的。生产者将消息存储在缓冲区中，并由 sender IO 线程负责将缓冲区中的消息批量发送到服务器。这种方式可以提高生产者的吞吐量，并减少网络传输压力。")]),v._v(" "),_("p",[v._v("Kafka 消费者是基于拉模式的，即消费者主动向服务端发起请求来拉取消息。Kafka 中的消息消费是一个不断轮询的过程，消费者所要做的就是重复地调用 "),_("code",[v._v("poll()")]),v._v(" 方法，而 "),_("code",[v._v("poll()")]),v._v(" 方法返回的是所订阅主题（或分区）上的一组消息³。")]),v._v(" "),_("p",[v._v("Kafka 消费者并不是通过操作系统异步回调来实现异步消费消息的。相反，它是通过消费者自己不断轮询来获取新的消息。这种方式可以让消费者更好地控制消息获取的速度和时间，从而保证消息消费的实时性。")]),v._v(" "),_("h3",{attrs:{id:"kafka短轮询有哪些优化方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kafka短轮询有哪些优化方法"}},[v._v("#")]),v._v(" kafka短轮询有哪些优化方法")]),v._v(" "),_("ul",[_("li",[v._v("并行消费")]),v._v(" "),_("li",[v._v("消费组消费")]),v._v(" "),_("li",[v._v("Kafka 时间轮算法实现延迟队列")])]),v._v(" "),_("h2",{attrs:{id:"netty"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#netty"}},[v._v("#")]),v._v(" Netty")]),v._v(" "),_("h3",{attrs:{id:"线程模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程模型"}},[v._v("#")]),v._v(" 线程模型")]),v._v(" "),_("p",[v._v("两组线程池：")]),v._v(" "),_("ul",[_("li",[v._v("BossGroup线程池， 负责接收连接请求，并将请求封装进NioSocketChannel")]),v._v(" "),_("li",[v._v("WorkerGroup线程池， 负责处理连接上的IO操作")])]),v._v(" "),_("h3",{attrs:{id:"线程之间的交互通信方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程之间的交互通信方式"}},[v._v("#")]),v._v(" 线程之间的交互通信方式")]),v._v(" "),_("ul",[_("li",[v._v("共享内存")]),v._v(" "),_("li",[v._v("管道")]),v._v(" "),_("li",[v._v("消息队列")]),v._v(" "),_("li",[v._v("RPC")]),v._v(" "),_("li",[v._v("线程同步机制")])]),v._v(" "),_("h2",{attrs:{id:"数据库的设计"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库的设计"}},[v._v("#")]),v._v(" 数据库的设计")]),v._v(" "),_("h2",{attrs:{id:"如何设计一个高并发系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何设计一个高并发系统"}},[v._v("#")]),v._v(" 如何设计一个高并发系统")]),v._v(" "),_("p",[v._v("高并发系统就是可以理解为设计一个系统，保证整体可用的同时，能够处理很高的并发用户请求，可以承受住很大的流量冲击。"),_("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/597249336#:~:text=%E5%AD%97%E8%8A%82%E4%B8%89%E9%9D%A2%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%201%201.%20%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%EF%BC%8C%E6%A8%AA%E5%90%91%E6%89%A9%E5%B1%95%202%202.%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%EF%BC%88%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86%EF%BC%89%203,%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%207%207.%20CDN%EF%BC%8C%E5%8A%A0%E9%80%9F%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%208%208.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E5%89%8A%E9%94%8B%20%E6%9B%B4%E5%A4%9A%E9%A1%B9%E7%9B%AE",target:"_blank",rel:"noopener noreferrer"}},[v._v("高并发"),_("OutboundLink")],1),v._v("。")]),v._v(" "),_("h3",{attrs:{id:"高并发常见的瓶颈问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#高并发常见的瓶颈问题"}},[v._v("#")]),v._v(" 高并发常见的瓶颈问题")]),v._v(" "),_("ul",[_("li",[v._v("内存不足")]),v._v(" "),_("li",[v._v("磁盘空间不足")]),v._v(" "),_("li",[v._v("连接数不足")]),v._v(" "),_("li",[v._v("网络带宽不够")])]),v._v(" "),_("h3",{attrs:{id:"具体方案措施"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#具体方案措施"}},[v._v("#")]),v._v(" 具体方案措施")]),v._v(" "),_("ol",[_("li",[v._v("分布式集群部署")]),v._v(" "),_("li",[v._v("微服务拆分")]),v._v(" "),_("li",[v._v("分库分表")]),v._v(" "),_("li",[v._v("池化技术")]),v._v(" "),_("li",[v._v("主从分离")]),v._v(" "),_("li",[v._v("使用缓存")]),v._v(" "),_("li",[v._v("CDN，加速静态资源访问")]),v._v(" "),_("li",[v._v("消息队列，削锋，降级熔断，限流")]),v._v(" "),_("li",[v._v("异步")])]),v._v(" "),_("h3",{attrs:{id:"一些常规的优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一些常规的优化"}},[v._v("#")]),v._v(" 一些常规的优化")]),v._v(" "),_("ol",[_("li",[v._v("在一次连接上批量操作数据库")]),v._v(" "),_("li",[v._v("异步思想")]),v._v(" "),_("li",[v._v("空间换时间，可以用缓存")]),v._v(" "),_("li",[v._v("异步非阻塞思想，IO多路复用")]),v._v(" "),_("li",[v._v("资源访问由串行变为并行")]),v._v(" "),_("li",[v._v("锁的粒度避免过粗")]),v._v(" "),_("li",[v._v("加索引")]),v._v(" "),_("li",[v._v("优化SQL")]),v._v(" "),_("li",[v._v("避免大事务问题")]),v._v(" "),_("li",[v._v("优化深分页问题(标签记录法/延迟关联法)")]),v._v(" "),_("li",[v._v("压缩传输内容")]),v._v(" "),_("li",[v._v("海量数据处理，可以考虑用NoSQL，像ES之类")]),v._v(" "),_("li",[v._v("JVM FULLGC，线程太多，IO太多资源没关闭")])]),v._v(" "),_("h2",{attrs:{id:"订单微服务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#订单微服务"}},[v._v("#")]),v._v(" 订单微服务")]),v._v(" "),_("h3",{attrs:{id:"订单基本概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#订单基本概念"}},[v._v("#")]),v._v(" 订单基本概念")]),v._v(" "),_("h4",{attrs:{id:"订单中心"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#订单中心"}},[v._v("#")]),v._v(" 订单中心")]),v._v(" "),_("ul",[_("li",[v._v("用户信息")]),v._v(" "),_("li",[v._v("订单信息")]),v._v(" "),_("li",[v._v("商品信息")]),v._v(" "),_("li",[v._v("物流信息")]),v._v(" "),_("li",[v._v("优惠促销信息")])]),v._v(" "),_("h4",{attrs:{id:"订单状态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#订单状态"}},[v._v("#")]),v._v(" 订单状态")]),v._v(" "),_("ul",[_("li",[v._v("创建订单")]),v._v(" "),_("li",[v._v("已付款")])]),v._v(" "),_("h4",{attrs:{id:"订单流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#订单流程"}},[v._v("#")]),v._v(" 订单流程")]),v._v(" "),_("p",[v._v("订单生成 -> 支付订单 -> 卖家发货 -> 确认收货 -> 交易完成\n下单， 下单数据校验，查询商品信息，优惠信息，运费信息等等，  库存锁定， 订单生成；\n订单支付，  支付回调， 发送异步消息 同步物流\n订单签收， 订单已完成")]),v._v(" "),_("h3",{attrs:{id:"订单微服务整体架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#订单微服务整体架构"}},[v._v("#")]),v._v(" 订单微服务整体架构")]),v._v(" "),_("h3",{attrs:{id:"接口幂等"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口幂等"}},[v._v("#")]),v._v(" 接口幂等")]),v._v(" "),_("ul",[_("li",[v._v("Token")]),v._v(" "),_("li",[v._v("加锁")]),v._v(" "),_("li",[v._v("唯一性约束")]),v._v(" "),_("li",[v._v("防重表")]),v._v(" "),_("li",[v._v("全局请求唯一ID")])]),v._v(" "),_("h3",{attrs:{id:"如何保证秒杀的时候不超卖和出现重复消费的情况"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何保证秒杀的时候不超卖和出现重复消费的情况"}},[v._v("#")]),v._v(" 如何保证秒杀的时候不超卖和出现重复消费的情况？")]),v._v(" "),_("ul",[_("li",[v._v("乐观锁或悲观锁来控制库存")]),v._v(" "),_("li",[v._v("使用消息队列来削峰，控制请求流量")]),v._v(" "),_("li",[v._v("限流")])]),v._v(" "),_("h3",{attrs:{id:"如何设计数据库连接池"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何设计数据库连接池"}},[v._v("#")]),v._v(" 如何设计数据库连接池")]),v._v(" "),_("p",[v._v("数据库连接池是一种用于管理数据库连接的技术。它的基本原理是在内部对象池中维护一定数量的数据库连接，并对外暴露数据库连接获取和返回方法。例如，外部使用者可以通过 "),_("code",[v._v("getConnection")]),v._v(" 方法获取连接，使用完毕后再通过 "),_("code",[v._v("releaseConnection")]),v._v(" 方法将连接返回。此时，连接并没有关闭，而是由连接池管理器回收，并为下一次使用做好准备¹。")]),v._v(" "),_("p",[v._v("数据库连接池的优势在于资源重用，由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。同时，在减少系统消耗的基础上，另一方面也增进了系统运行环境的平稳性（减少内存碎片以及数据库临时进程/线程的数量）。此外，数据库连接池还能提供更快的系统响应速度，因为在初始化过程中，往往已经创建了若干数据库连接置于池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。")]),v._v(" "),_("p",[v._v("设计一个数据库连接池需要考虑许多因素，包括最大活跃数、最大空闲数、最大空闲时间等参数。")]),v._v(" "),_("h3",{attrs:{id:"如何设计aop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何设计aop"}},[v._v("#")]),v._v(" 如何设计AOP")]),v._v(" "),_("p",[v._v("如果我要设计一个AOP（面向切面编程），我会考虑以下几个方面：")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("定义切面")]),v._v("：首先，我需要定义切面，即确定哪些功能需要被抽离出来，以便在不影响核心业务逻辑的情况下进行维护和管理。例如，日志统计、打点上报、异常处理等功能都可以被抽离出来¹。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("动态织入")]),v._v("：其次，我需要考虑如何将这些功能动态织入到业务逻辑模块中。这可以通过预编译方式和运行期间动态代理实现³⁴。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("切入点选择")]),v._v("：接下来，我需要确定切入点，即选择哪些连接点需要被切入。这可以通过方法匹配表达式来实现²。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("编程思路")]),v._v("：最后，我需要考虑AOP的编程思路。由于AOP是针对方法调用进行编程的，因此我需要考虑如何捕获方法调用，并在代理过程中插入业务代码²。")])])]),v._v(" "),_("p",[v._v("总之，设计一个AOP需要考虑许多因素，包括切面定义、动态织入、切入点选择和编程思路等。")]),v._v(" "),_("h3",{attrs:{id:"设计秒杀系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计秒杀系统"}},[v._v("#")]),v._v(" 设计秒杀系统")]),v._v(" "),_("ul",[_("li",[v._v("高并发")]),v._v(" "),_("li",[v._v("高可用")]),v._v(" "),_("li",[v._v("数据一致性")]),v._v(" "),_("li",[v._v("安全性\n对于一个秒杀系统，可以理解为很多请求去 抢100个名额，\n首先 怎么保证服务器/数据库能承受住这么大的流量，")]),v._v(" "),_("li",[v._v("负载均衡、动静分离(Nginx)、CDN加速(就近获取内容)、流量削峰，限流，熔断降级，异步处理，缓存，主从分离，读写分离")]),v._v(" "),_("li",[v._v("库存预热，将库存信息需要从数据库中加载到缓存中，在缓存中查验 和 扣减库存\n其次，就是如何让并发的请求正确消费这 100个名额")])]),v._v(" "),_("p",[v._v("在分布式环境中，为了防止超卖，我们可以使用分布式锁。具体的实现方式有很多，这里以Redis为例来说明：")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("加锁")]),v._v("：当一个请求需要修改库存时，首先尝试获取锁。在Redis中，我们可以使用"),_("code",[v._v("SETNX")]),v._v("命令来实现。"),_("code",[v._v("SETNX")]),v._v("命令只有在key不存在时才会设置成功，因此可以保证只有一个请求能够获取到锁。为了防止死锁，我们还需要为锁设置一个过期时间，可以使用"),_("code",[v._v("EXPIRE")]),v._v("命令来实现。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("设计key和value")]),v._v("：在分布式锁中，key通常是需要保护的资源，例如商品的ID。value则可以是一个随机生成的唯一标识（例如UUID），用来标识锁的拥有者。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("释放锁")]),v._v("：当请求处理完毕后，需要释放锁。在Redis中，我们可以使用"),_("code",[v._v("DEL")]),v._v("命令来删除锁。但是为了防止误删其他请求的锁，我们需要先判断当前请求是否是锁的拥有者¹。这个操作需要是原子性的，因此我们可以使用Lua脚本来实现。")])])]),v._v(" "),_("h2",{attrs:{id:"linux指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#linux指令"}},[v._v("#")]),v._v(" Linux指令")]),v._v(" "),_("h3",{attrs:{id:"常用的一些命令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常用的一些命令"}},[v._v("#")]),v._v(" 常用的一些命令")]),v._v(" "),_("p",[v._v("在面试中，你可能会被问到以下一些常用的Linux命令：")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("文件管理")]),v._v("："),_("code",[v._v("ls")]),v._v("（显示目录中的文件及其属性信息）¹²，"),_("code",[v._v("cp")]),v._v("（复制文件或目录）¹²，"),_("code",[v._v("mkdir")]),v._v("（创建目录）¹²，"),_("code",[v._v("mv")]),v._v("（移动或重命名文件）¹²，"),_("code",[v._v("pwd")]),v._v("（显示当前工作目录的路径）¹²，"),_("code",[v._v("tar")]),v._v("（压缩和解压缩文件）¹²。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("文档编辑")]),v._v("："),_("code",[v._v("cat")]),v._v("（在终端设备上显示文件内容）²，"),_("code",[v._v("grep")]),v._v("（强大的文本搜索工具）²，"),_("code",[v._v("tail")]),v._v("（查看文件尾部内容）²。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("系统管理")]),v._v("："),_("code",[v._v("find")]),v._v("（根据路径和条件搜索指定文件）²，"),_("code",[v._v("rpm")]),v._v("（RPM软件包管理器）²，"),_("code",[v._v("uname")]),v._v("（显示系统内核信息）²。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("磁盘管理")]),v._v("："),_("code",[v._v("df")]),v._v("（显示磁盘空间使用量情况）²，"),_("code",[v._v("fdisk")]),v._v("（管理磁盘分区）²，"),_("code",[v._v("mount")]),v._v("（将文件系统挂载到目录）²。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("文件传输")]),v._v("： "),_("code",[v._v("tftp")]),v._v("（上传及下载文件）²， "),_("code",[v._v("rsync")]),v._v("（远程数据同步工具）².")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("网络通讯")]),v._v("： "),_("code",[v._v("ssh")]),v._v("（安全的远程连接服务器）², "),_("code",[v._v("netstat")]),v._v("(显示网络状态)², "),_("code",[v._v("ping")]),v._v("(测试主机间网络连通性)².")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("设备管理")]),v._v("： "),_("code",[v._v("mount")]),v._v("(将文件系统挂载到目录)², "),_("code",[v._v("lspci")]),v._v("(显示当前设备PCI总线设备信息)².")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("备份压缩")]),v._v("： "),_("code",[v._v("zip")]),v._v("(压缩文件)², "),_("code",[v._v("gzip")]),v._v("(压缩和解压文件)².")])])]),v._v(" "),_("h3",{attrs:{id:"grep-的常用用法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#grep-的常用用法"}},[v._v("#")]),v._v(" grep 的常用用法")]),v._v(" "),_("p",[v._v("以下是一些 grep 的使用示例：")]),v._v(" "),_("p",[v._v("在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：\ngrep hello file.txt")]),v._v(" "),_("p",[v._v("在文件夹 dir 中递归查找所有文件中匹配正则表达式 “pattern” 的行，并打印匹配行所在的文件名和行号：\ngrep -r -n pattern dir/")]),v._v(" "),_("p",[v._v('在标准输入中查找字符串 “world”，并只打印匹配的行数：\necho "hello world" | grep -c world')]),v._v(" "),_("p",[v._v("在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行：\ngrep test *file")]),v._v(" "),_("h3",{attrs:{id:"文件数据量大-查看文件内容"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#文件数据量大-查看文件内容"}},[v._v("#")]),v._v(" 文件数据量大，查看文件内容")]),v._v(" "),_("p",[v._v("当文件数据量非常大时，我们可以使用一些特定的命令来查看文件内容，而不必打开整个文件。以下是一些常用的命令：")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[_("code",[v._v("less")])]),v._v("："),_("code",[v._v("less")]),v._v(" 命令可以用来查看大文件的内容。它允许你在文件中上下移动，这样你就可以遍历内容，然后在文件中回退¹。")])]),v._v(" "),_("li",[_("p",[_("strong",[_("code",[v._v("head")])]),v._v("：如果只想看一个文件的前几行，可以用 "),_("code",[v._v("head")]),v._v(" 命令¹。")])]),v._v(" "),_("li",[_("p",[_("strong",[_("code",[v._v("tail")])]),v._v("：与 "),_("code",[v._v("head")]),v._v(" 相对，"),_("code",[v._v("tail")]),v._v(" 是只显示末尾几行。比如我们想查看一个文件的更新情况，只要看最后几行就可以了¹。")])]),v._v(" "),_("li",[_("p",[_("strong",[_("code",[v._v("grep")])]),v._v("：从一个文件中查找到某个关键词，并将包含该关键词的行显示出来¹。")])]),v._v(" "),_("li",[_("p",[_("strong",[_("code",[v._v("cat | more")])]),v._v("：这个命令组合可以用来分页查看文件内容⁴。")])]),v._v(" "),_("li",[_("p",[_("strong",[_("code",[v._v("find / -type f -size +1G -print0 | xargs -0 du -h | sort -nr")])]),v._v("：这个命令组合可以用来查找大于1G的文件，并按照大小排序²。")])])]),v._v(" "),_("h3",{attrs:{id:"linux-中查找端口并找到流量最大的端口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#linux-中查找端口并找到流量最大的端口"}},[v._v("#")]),v._v(" Linux 中查找端口并找到流量最大的端口")]),v._v(" "),_("p",[v._v("在 Linux 中，"),_("code",[v._v("netstat")]),v._v(" 命令可以用来显示网络状态，包括 TCP 和 UDP 连接、监听的端口、以及每个网络接口设备的状态信息¹²。然而，"),_("code",[v._v("netstat")]),v._v(" 并不能直接显示每个端口的流量。要查看每个端口的流量，你可能需要使用其他的工具或方法。")]),v._v(" "),_("p",[v._v("一种可能的方法是使用 "),_("code",[v._v("iftop")]),v._v(" 或 "),_("code",[v._v("nethogs")]),v._v(" 这样的工具来查看网络流量。这些工具可以显示每个连接的流量，从而让你找到流量最大的连接。然后，你可以使用 "),_("code",[v._v("netstat")]),v._v(" 或 "),_("code",[v._v("ss")]),v._v(" 命令来查看这些连接对应的端口。")]),v._v(" "),_("p",[v._v("例如，你可以先使用 "),_("code",[v._v("nethogs")]),v._v(" 来查看网络流量：")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("sudo nethogs\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("p",[v._v("然后，你可以使用 "),_("code",[v._v("netstat")]),v._v(" 来查看对应的端口：")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("sudo netstat -tunlp\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("p",[v._v("在这个命令中，"),_("code",[v._v("-tunlp")]),v._v(" 参数表示显示 TCP ("),_("code",[v._v("-t")]),v._v(") 和 UDP ("),_("code",[v._v("-u")]),v._v(") 连接，不解析服务和主机名 ("),_("code",[v._v("-n")]),v._v(")，并显示监听的端口 ("),_("code",[v._v("-l")]),v._v(") 和对应的进程信息 ("),_("code",[v._v("-p")]),v._v(")。")]),v._v(" "),_("h3",{attrs:{id:"git常用指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#git常用指令"}},[v._v("#")]),v._v(" git常用指令")]),v._v(" "),_("p",[v._v("在面试中，你可能会被问到以下一些常用的Git命令：")]),v._v(" "),_("ol",[_("li",[_("strong",[_("code",[v._v("git config")])]),v._v("：配置信息¹³。")]),v._v(" "),_("li",[_("strong",[_("code",[v._v("git init")])]),v._v("：初始化本地git仓库（创建新仓库）¹²。")]),v._v(" "),_("li",[_("strong",[_("code",[v._v("git clone")])]),v._v("：拷贝一份远程仓库，也就是下载一个项目¹²。")]),v._v(" "),_("li",[_("strong",[_("code",[v._v("git add")])]),v._v("：添加文件到暂存区¹²。")]),v._v(" "),_("li",[_("strong",[_("code",[v._v("git commit")])]),v._v("：提交暂存区到本地仓库¹²。")]),v._v(" "),_("li",[_("strong",[_("code",[v._v("git status")])]),v._v("：查看仓库当前的状态，显示有变更的文件¹³。")]),v._v(" "),_("li",[_("strong",[_("code",[v._v("git diff")])]),v._v("：比较文件的不同，即暂存区和工作区的差异¹³。")]),v._v(" "),_("li",[_("strong",[_("code",[v._v("git reset HEAD")])]),v._v("：取消缓存命令³。")]),v._v(" "),_("li",[_("strong",[_("code",[v._v("git rm")])]),v._v("：将文件从暂存区和工作区中删除¹³。")]),v._v(" "),_("li",[_("strong",[_("code",[v._v("git mv")])]),v._v("：移动或重命名工作区文件。")])])])}),[],!1,null,null,null);_.default=r.exports}}]);