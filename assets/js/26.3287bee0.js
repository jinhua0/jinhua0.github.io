(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{358:function(a,e,t){"use strict";t.r(e);var r=t(4),n=Object(r.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"容器篇ioc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器篇ioc"}},[a._v("#")]),a._v(" 容器篇IOC")]),a._v(" "),e("h2",{attrs:{id:"定义一个简单的spring容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义一个简单的spring容器"}},[a._v("#")]),a._v(" 定义一个简单的Spring容器")]),a._v(" "),e("p",[a._v("用于定义、存放和获取Bean对象。")]),a._v(" "),e("ul",[e("li",[a._v("定义：BeanDefinition")]),a._v(" "),e("li",[a._v("注册：我们把数据存放到HashMap中，存放的是定义了Bean的对象信息")]),a._v(" "),e("li",[a._v("获取：最后是获取对象，Bean的名字就是key,Spring容器初始化好Bean之后，就可以直接获取了")])]),a._v(" "),e("h2",{attrs:{id:"运用设计模式-实现bean的定义、注册、获取"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#运用设计模式-实现bean的定义、注册、获取"}},[a._v("#")]),a._v(" 运用设计模式，实现Bean的定义、注册、获取")]),a._v(" "),e("ul",[e("li",[a._v("首先我们需要定义BeanFactory这样一个Bean工厂，提供Bean的获取方法"),e("code",[a._v("getBean(String name)")]),a._v("，之后这个Bean工厂接口由抽象类AbstractBeanFactory实现。")]),a._v(" "),e("li",[a._v("那么在继承抽象类AbstractBeanFactory后AbstractAutowireCapableBeanFactory 就可以实现相应的抽象方法了，因为AbstractAutowireCapableBeanFactory 本手也是一个抽象类，所以只会实现属于自己的抽象方法，其他抽象方法由继承AbstractAutowireCapableBeanFactory类实现")])]),a._v(" "),e("h2",{attrs:{id:"基于cglib实现含构造函数的类实例化策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于cglib实现含构造函数的类实例化策略"}},[a._v("#")]),a._v(" 基于Cglib实现含构造函数的类实例化策略")]),a._v(" "),e("ul",[e("li",[a._v("在BeanFactory中添加Object getBean(String name, Object... args)接口，这样就可以在获取Bean时把构造函数的入参信息传递进去")]),a._v(" "),e("li",[a._v("这里有两种方式创建含有构造函数的Bean对象，一个是JDK自带的方法"),e("code",[a._v("DeclaredConstructor")]),a._v("，另一个是使用Cglib来创建Bean对象(enhancer,create(...))")])]),a._v(" "),e("h2",{attrs:{id:"为bean对象注入属性和依赖bean的功能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为bean对象注入属性和依赖bean的功能"}},[a._v("#")]),a._v(" 为Bean对象注入属性和依赖Bean的功能")]),a._v(" "),e("h2",{attrs:{id:"设计和实现资源加载器-从spring解析和注册bean对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计和实现资源加载器-从spring解析和注册bean对象"}},[a._v("#")]),a._v(" 设计和实现资源加载器，从Spring解析和注册Bean对象")]),a._v(" "),e("h2",{attrs:{id:"实现应用上下文"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现应用上下文"}},[a._v("#")]),a._v(" 实现应用上下文")]),a._v(" "),e("ul",[e("li",[a._v("满足于对 Bean 对象扩展的两个接口，其实也是 Spring 框架中非常具有重量级的两个接口："),e("code",[a._v("BeanFactoryProcessor")]),a._v("和"),e("code",[a._v("BeanPostProcessor")]),a._v("，也几乎是在使用Spring框架之外自己组建需求的两个必备接口")]),a._v(" "),e("li",[e("code",[a._v("BeanFactoryPostProcessor")]),a._v("是Spring框架提供的容器扩展机制，允许在Bean对象注册后但未实例化前，对Bean的定义信息BeanDefinition进行修改操作。")]),a._v(" "),e("li",[a._v("BeanPostProcessor,也是Spring提供的扩展机制，不过是在Bean对象实例化之后修改Bean对象，也可以替换Bean对象，与后面的AOP有着密切关系")]),a._v(" "),e("li",[a._v("同时如果只是添加这两个接口，不做任何包装，使用起来非常麻烦，开发Spring的上下文操作类，把相应的XML加载、注册以及新增的修改和扩展都融合进去，让Spring自己扫描到我们的新增服务，便于用户使用。")])]),a._v(" "),e("h2",{attrs:{id:"初始化和销毁方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#初始化和销毁方法"}},[a._v("#")]),a._v(" 初始化和销毁方法")]),a._v(" "),e("ul",[e("li",[a._v("在spring.xml配置中添加"),e("code",[a._v("init-method")]),a._v("、"),e("code",[a._v("destory-method")]),a._v("两个注解，在配置文件加载的过程中，把注解配置一并定义到BeanDefinition属性当中。这样在initializeBean初始化操作的工程中，就可以通过反射的方式来调用配置在Bean定义属性当中的方法信息了。另外如果是接口实现的方式，那么直接可以通过Bean对象调用对应接口定义的方法，afterPropertiesSet().")]),a._v(" "),e("li",[a._v("除了在初始化做的操作外，"),e("code",[a._v("destroy-method")]),a._v("和"),e("code",[a._v("DisposableBean")]),a._v("接口的定义，都会在bean对象初始完成阶段，执行注册销毁方法的信息到 DefaultSingletonBeanRegistry 类中的 disposableBeans 属性里，这是为了后续统一进行操作。")])]),a._v(" "),e("h2",{attrs:{id:"aware感知容器对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aware感知容器对象"}},[a._v("#")]),a._v(" Aware感知容器对象")]),a._v(" "),e("ul",[e("li",[a._v("定义接口Aware，在Spring框架中它是一种感知标记性接口，具体的子类去定义 和 实现感知容器的相关对象，也是通过这个桥梁，向具体的实现类中提供容器服务。")]),a._v(" "),e("li",[a._v("继承Aware接口包括：BeanFactoryAware、BeanClassLoaderAware、BeanNameAware和ApplicationContextAware.")])]),a._v(" "),e("h2",{attrs:{id:"对象作用域和factorybean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象作用域和factorybean"}},[a._v("#")]),a._v(" 对象作用域和FactoryBean")]),a._v(" "),e("ul",[e("li",[a._v("FactoryBean 是 Spring 框架中的一个特殊接口，它是一个工厂Bean，用于创建和管理特定类型的对象。FactoryBean 接口允许开发人员自定义对象的创建逻辑，并将其纳入 Spring 的 IoC 容器管理。")])]),a._v(" "),e("h2",{attrs:{id:"容器事件和事件监听器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器事件和事件监听器"}},[a._v("#")]),a._v(" 容器事件和事件监听器")]),a._v(" "),e("ul",[e("li",[a._v("基于观察者模式实现")]),a._v(" "),e("li",[a._v("在Spring中有一个Event事件功能，可以提供事件的定义、发布以及监听事件来完成一些自定义的动作。比如可以定义一个新用户注册事件，当有用户执行注册完成后，在事件监听中给用户发送一些些优惠券和短信，这样就可以把注册和对应的策略服务分开，降低系统的耦合。以后还可以扩展注册服务，比如需要添加风控策略，添加实名认证、判断用户属性等等都不会影响到依赖注册成功后执行的动作。")]),a._v(" "),e("li",[a._v("在整个功能实现过程中，仍然需要在面向用户的应用上下文 "),e("code",[a._v("AbstractApplicationContext")]),a._v(" 中添加相关事件内容，包括：初始化事件发布者、注册事件监听器、发布容器刷新完成事件。")]),a._v(" "),e("li",[a._v("使用观察者模式定义事件类、监听类、发布类，同时还需要完成一个广播器的功能，接收到事件推送时进行分析处理符合监听事件接受者感兴趣的事件，也就是使用 isAssignableFrom 进行判断。")]),a._v(" "),e("li",[a._v("isAssignableFrom 和 instanceof 相似，不过 isAssignableFrom 是用来判断子类和父类的关系的，或者接口的实现类和接口的关系的，默认所有的类的终极父类都是Object。如果A.isAssignableFrom(B)结果是true，证明B可以转换成为A,也就是A可以由B转换而来。")]),a._v(" "),e("li",[a._v("ApplicationEvent 是定义事件的抽象类，所有的事件包括关闭、刷新，以及用户自己实现的事件，都需要继承这个类。")]),a._v(" "),e("li",[a._v("ContextClosedEvent、ContextRefreshedEvent，分别是 Spring 框架自己实现的两个事件类，可以用于监听刷新和关闭动作。")])]),a._v(" "),e("h1",{attrs:{id:"代理篇aop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代理篇aop"}},[a._v("#")]),a._v(" 代理篇AOP")]),a._v(" "),e("h2",{attrs:{id:"基于jdk和cglib动态代理-实现aop核心功能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于jdk和cglib动态代理-实现aop核心功能"}},[a._v("#")]),a._v(" 基于JDK和Cglib动态代理，实现AOP核心功能")]),a._v(" "),e("h2",{attrs:{id:"把aop动态代理-融入到bean的生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#把aop动态代理-融入到bean的生命周期"}},[a._v("#")]),a._v(" 把AOP动态代理，融入到Bean的生命周期")]),a._v(" "),e("h2",{attrs:{id:"通过注解配置和包自动扫描的方式完成bean对象的注册"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通过注解配置和包自动扫描的方式完成bean对象的注册"}},[a._v("#")]),a._v(" 通过注解配置和包自动扫描的方式完成Bean对象的注册")]),a._v(" "),e("h2",{attrs:{id:"通过注解给属性注入配置和bean对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通过注解给属性注入配置和bean对象"}},[a._v("#")]),a._v(" 通过注解给属性注入配置和Bean对象")]),a._v(" "),e("h2",{attrs:{id:"给代理对象的属性设置值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#给代理对象的属性设置值"}},[a._v("#")]),a._v(" 给代理对象的属性设置值")])])}),[],!1,null,null,null);e.default=n.exports}}]);